# Story 5.3: Implement Edge Caching

**Epic:** 5 - CBE Distribution  
**Story Number:** 5.3  
**Title:** Deploy Edge Caching Strategy  
**Status:** READY  
**Points:** 3  
**Component:** 533 (Edge Caching)  

---

## Story

**As a** Performance Engineer,  
**I want** intelligent edge caching across all PoPs,  
**so that** content is served with minimal latency and reduced origin load.

---

## Acceptance Criteria

1. Edge caching deployed at 50+ PoPs globally
2. Cache hit ratio > 85% for static content
3. Dynamic content caching with personalization
4. Cache invalidation < 30 seconds globally
5. Bandwidth costs reduced by 60%
6. Cache warming for critical content
7. A/B testing support at edge
8. Real-time cache analytics dashboard

---

## Tasks / Subtasks

### Task 1: Write Edge Caching Tests (TDD) (AC: 2, 3, 4)
- [ ] Create `distribution/edge_cache_test.go`
  - [ ] Test cache hit ratios
  - [ ] Test invalidation speed
  - [ ] Test dynamic caching
  - [ ] Test cache warming
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy Edge Cache Infrastructure (AC: 1, 2)
- [ ] Configure Azure Front Door Premium
  ```hcl
  resource "azurerm_cdn_frontdoor_profile" "main" {
    name                = "afd-oversight-global"
    resource_group_name = azurerm_resource_group.cdn.name
    sku_name           = "Premium_AzureFrontDoor"
    
    tags = {
      environment = "production"
      component   = "edge-cache"
    }
  }
  
  resource "azurerm_cdn_frontdoor_endpoint" "global" {
    name                     = "afd-oversight-endpoint"
    cdn_frontdoor_profile_id = azurerm_cdn_frontdoor_profile.main.id
    
    tags = {
      environment = "production"
    }
  }
  
  resource "azurerm_cdn_frontdoor_origin_group" "main" {
    name                     = "main-origin-group"
    cdn_frontdoor_profile_id = azurerm_cdn_frontdoor_profile.main.id
    
    load_balancing {
      sample_size                        = 4
      successful_samples_required        = 3
      additional_latency_in_milliseconds = 50
    }
    
    health_probe {
      path                = "/health"
      request_type        = "GET"
      protocol           = "Https"
      interval_in_seconds = 30
    }
  }
  
  resource "azurerm_cdn_frontdoor_origin" "regions" {
    for_each = var.regions
    
    name                          = "origin-${each.key}"
    cdn_frontdoor_origin_group_id = azurerm_cdn_frontdoor_origin_group.main.id
    
    enabled                        = true
    host_name                     = azurerm_app_service.regional[each.key].default_site_hostname
    http_port                     = 80
    https_port                    = 443
    origin_host_header            = azurerm_app_service.regional[each.key].default_site_hostname
    priority                      = each.value.priority
    weight                        = 1000
    certificate_name_check_enabled = true
  }
  
  resource "azurerm_cdn_frontdoor_route" "app" {
    name                          = "route-app"
    cdn_frontdoor_endpoint_id     = azurerm_cdn_frontdoor_endpoint.global.id
    cdn_frontdoor_origin_group_id = azurerm_cdn_frontdoor_origin_group.main.id
    cdn_frontdoor_origin_ids     = values(azurerm_cdn_frontdoor_origin.regions)[*].id
    
    supported_protocols    = ["Http", "Https"]
    patterns_to_match     = ["/*"]
    forwarding_protocol   = "HttpsOnly"
    link_to_default_domain = true
    https_redirect_enabled = true
    
    cache_configuration {
      query_string_caching_behavior = "UseQueryString"
      query_strings                = ["v", "api-version"]
      compression_enabled          = true
      
      content_types_to_compress = [
        "text/html",
        "text/css",
        "text/javascript",
        "application/javascript",
        "application/json",
        "application/xml",
        "image/svg+xml"
      ]
    }
  }
  ```
- [ ] Setup Varnish at edge
  ```yaml
  # varnish/default.vcl
  vcl 4.1;
  
  import std;
  import directors;
  
  backend primary {
      .host = "app-oversight-eus.azurewebsites.net";
      .port = "443";
      .ssl = true;
      .probe = {
          .url = "/health";
          .timeout = 2s;
          .interval = 10s;
          .window = 5;
          .threshold = 3;
      }
  }
  
  backend secondary {
      .host = "app-oversight-weu.azurewebsites.net";
      .port = "443";
      .ssl = true;
      .probe = {
          .url = "/health";
          .timeout = 2s;
          .interval = 10s;
      }
  }
  
  sub vcl_init {
      new lb = directors.round_robin();
      lb.add_backend(primary);
      lb.add_backend(secondary);
  }
  
  sub vcl_recv {
      set req.backend_hint = lb.backend();
      
      # Normalize URL
      set req.url = std.tolower(req.url);
      set req.url = regsub(req.url, "#.*$", "");
      set req.url = regsub(req.url, "\?$", "");
      
      # Cache static assets
      if (req.url ~ "\.(jpg|jpeg|png|gif|ico|webp|svg|css|js|woff|woff2|ttf)$") {
          unset req.http.Cookie;
          return (hash);
      }
      
      # Cache API responses
      if (req.url ~ "^/api/" && req.method == "GET") {
          return (hash);
      }
      
      # Pass authenticated requests
      if (req.http.Authorization || req.http.Cookie ~ "session=") {
          return (pass);
      }
  }
  
  sub vcl_backend_response {
      # Set cache TTLs
      if (bereq.url ~ "\.(jpg|jpeg|png|gif|ico|webp|svg|woff|woff2|ttf)$") {
          set beresp.ttl = 30d;
          set beresp.http.Cache-Control = "public, max-age=2592000";
      } elsif (bereq.url ~ "\.(css|js)$") {
          set beresp.ttl = 7d;
          set beresp.http.Cache-Control = "public, max-age=604800";
      } elsif (bereq.url ~ "^/api/") {
          set beresp.ttl = 60s;
          set beresp.http.Cache-Control = "public, max-age=60";
      }
      
      # Enable grace mode
      set beresp.grace = 6h;
      
      # Add cache headers
      set beresp.http.X-Cache-TTL = beresp.ttl;
      set beresp.http.X-Cache-Grace = beresp.grace;
  }
  
  sub vcl_deliver {
      # Add cache status header
      if (obj.hits > 0) {
          set resp.http.X-Cache = "HIT";
          set resp.http.X-Cache-Hits = obj.hits;
      } else {
          set resp.http.X-Cache = "MISS";
      }
      
      # Security headers
      set resp.http.X-Content-Type-Options = "nosniff";
      set resp.http.X-Frame-Options = "SAMEORIGIN";
      set resp.http.X-XSS-Protection = "1; mode=block";
  }
  ```
- [ ] Configure CloudFlare Workers
  ```javascript
  // cloudflare-worker.js
  addEventListener('fetch', event => {
    event.respondWith(handleRequest(event.request))
  })
  
  async function handleRequest(request) {
    const cache = caches.default;
    const cacheKey = new Request(request.url, request);
    
    // Check cache
    let response = await cache.match(cacheKey);
    
    if (response) {
      // Cache hit
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: {
          ...response.headers,
          'X-Cache': 'HIT',
          'X-Edge-Location': CF.colo
        }
      });
    }
    
    // Cache miss - fetch from origin
    response = await fetchFromOrigin(request);
    
    // Cache successful responses
    if (response.ok) {
      const headers = new Headers(response.headers);
      headers.set('Cache-Control', getCacheControl(request.url));
      
      const cachedResponse = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
      
      event.waitUntil(cache.put(cacheKey, cachedResponse.clone()));
      
      headers.set('X-Cache', 'MISS');
      headers.set('X-Edge-Location', CF.colo);
      
      return new Response(cachedResponse.body, {
        status: cachedResponse.status,
        statusText: cachedResponse.statusText,
        headers
      });
    }
    
    return response;
  }
  
  function getCacheControl(url) {
    if (url.match(/\.(jpg|jpeg|png|gif|webp|svg|ico)$/)) {
      return 'public, max-age=31536000, immutable';
    }
    if (url.match(/\.(css|js)$/)) {
      return 'public, max-age=604800';
    }
    if (url.includes('/api/')) {
      return 'public, max-age=60, must-revalidate';
    }
    return 'public, max-age=300';
  }
  ```
- [ ] Setup cache distribution
- [ ] Configure cache hierarchy

### Task 3: Implement Dynamic Caching (AC: 3)
- [ ] Configure ESI (Edge Side Includes)
  ```javascript
  // services/esi-processor.js
  class ESIProcessor {
    async processTemplate(template, context) {
      const esiPattern = /<esi:include\s+src="([^"]+)"(?:\s+cache="([^"]+)")?\s*\/>/g;
      let processed = template;
      let match;
      
      const includes = [];
      while ((match = esiPattern.exec(template)) !== null) {
        includes.push({
          tag: match[0],
          src: match[1],
          cache: match[2] || 'default'
        });
      }
      
      // Process includes in parallel
      const results = await Promise.all(
        includes.map(inc => this.fetchInclude(inc, context))
      );
      
      // Replace ESI tags with content
      includes.forEach((inc, i) => {
        processed = processed.replace(inc.tag, results[i]);
      });
      
      return processed;
    }
    
    async fetchInclude(include, context) {
      const cacheKey = this.getCacheKey(include.src, context);
      
      // Check cache
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      // Fetch content
      const url = this.buildUrl(include.src, context);
      const response = await fetch(url, {
        headers: {
          'X-ESI-Context': JSON.stringify(context),
          'X-User-Segment': context.userSegment
        }
      });
      
      const content = await response.text();
      
      // Cache based on policy
      const ttl = this.getCacheTTL(include.cache);
      if (ttl > 0) {
        await this.cache.set(cacheKey, content, ttl);
      }
      
      return content;
    }
    
    getCacheKey(src, context) {
      const parts = [src];
      
      // Add context-specific parts
      if (src.includes('/user/')) {
        parts.push(context.userId);
      }
      if (src.includes('/geo/')) {
        parts.push(context.country);
      }
      if (src.includes('/segment/')) {
        parts.push(context.userSegment);
      }
      
      return parts.join(':');
    }
  }
  ```
- [ ] Setup personalization caching
  ```javascript
  // services/personalization-cache.js
  class PersonalizationCache {
    constructor() {
      this.segmentCache = new Map();
      this.userCache = new LRU({ max: 10000, ttl: 3600000 });
    }
    
    async getCachedResponse(request, userContext) {
      const segment = await this.getUserSegment(userContext);
      const cacheKey = this.buildCacheKey(request, segment);
      
      // Check segment cache first
      const segmentCached = this.segmentCache.get(cacheKey);
      if (segmentCached) {
        return this.personalizeResponse(segmentCached, userContext);
      }
      
      // Check user-specific cache
      const userCacheKey = `${cacheKey}:${userContext.userId}`;
      const userCached = this.userCache.get(userCacheKey);
      if (userCached) {
        return userCached;
      }
      
      return null;
    }
    
    async cacheResponse(request, response, userContext) {
      const segment = await this.getUserSegment(userContext);
      const cacheKey = this.buildCacheKey(request, segment);
      
      // Extract personalizable parts
      const { base, personalizable } = this.extractParts(response);
      
      // Cache base content by segment
      this.segmentCache.set(cacheKey, {
        base,
        personalizable,
        segment
      });
      
      // Cache full response for user
      const userCacheKey = `${cacheKey}:${userContext.userId}`;
      this.userCache.set(userCacheKey, response);
    }
    
    personalizeResponse(cached, userContext) {
      let response = cached.base;
      
      // Apply personalizations
      for (const part of cached.personalizable) {
        const value = this.getPersonalizedValue(part.key, userContext);
        response = response.replace(part.placeholder, value);
      }
      
      return response;
    }
    
    getUserSegment(userContext) {
      // Segment users for cache efficiency
      const factors = [
        userContext.plan || 'free',
        userContext.country || 'US',
        userContext.language || 'en',
        userContext.deviceType || 'desktop'
      ];
      
      return factors.join('-');
    }
  }
  ```
- [ ] Configure cache variations
- [ ] Test dynamic content caching

### Task 4: Implement Cache Invalidation (AC: 4)
- [ ] Create invalidation service
  ```javascript
  // services/cache-invalidation.js
  class CacheInvalidation {
    constructor() {
      this.providers = {
        cloudflare: new CloudflareAPI(),
        fastly: new FastlyAPI(),
        akamai: new AkamaiAPI(),
        azureFrontDoor: new AzureFrontDoorAPI()
      };
      this.invalidationQueue = [];
    }
    
    async invalidate(patterns, options = {}) {
      const invalidationId = this.generateId();
      
      console.log(`Starting cache invalidation ${invalidationId}: ${patterns.join(', ')}`);
      
      const invalidation = {
        id: invalidationId,
        patterns,
        options,
        startTime: Date.now(),
        status: 'in-progress'
      };
      
      // Add to tracking
      this.invalidationQueue.push(invalidation);
      
      try {
        // Invalidate across all providers
        const promises = Object.entries(this.providers).map(([name, provider]) =>
          this.invalidateProvider(provider, patterns, name)
        );
        
        const results = await Promise.allSettled(promises);
        
        // Check results
        const failed = results.filter(r => r.status === 'rejected');
        if (failed.length > 0) {
          throw new Error(`Invalidation failed on ${failed.length} providers`);
        }
        
        invalidation.status = 'completed';
        invalidation.endTime = Date.now();
        invalidation.duration = invalidation.endTime - invalidation.startTime;
        
        console.log(`Invalidation ${invalidationId} completed in ${invalidation.duration}ms`);
        
        // Verify invalidation
        if (options.verify) {
          await this.verifyInvalidation(patterns);
        }
        
        return invalidation;
      } catch (error) {
        invalidation.status = 'failed';
        invalidation.error = error.message;
        throw error;
      }
    }
    
    async invalidateProvider(provider, patterns, name) {
      console.log(`Invalidating ${name}: ${patterns.join(', ')}`);
      
      const startTime = Date.now();
      
      try {
        await provider.purge(patterns);
        
        const duration = Date.now() - startTime;
        console.log(`${name} invalidation completed in ${duration}ms`);
        
        return { provider: name, duration, status: 'success' };
      } catch (error) {
        console.error(`${name} invalidation failed:`, error);
        throw error;
      }
    }
    
    async instantInvalidation(patterns) {
      // Use cache tags for instant invalidation
      const tags = patterns.map(p => this.patternToTag(p));
      
      await Promise.all([
        this.providers.cloudflare.purgeByTags(tags),
        this.providers.fastly.softPurgeByTags(tags)
      ]);
      
      // Also broadcast to edge nodes
      await this.broadcastInvalidation({
        type: 'immediate',
        tags,
        timestamp: Date.now()
      });
    }
    
    async verifyInvalidation(patterns, maxAttempts = 10) {
      const testUrls = patterns.map(p => this.patternToTestUrl(p));
      
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        await this.sleep(3000); // Wait 3 seconds between checks
        
        const results = await Promise.all(
          testUrls.map(url => this.checkCacheStatus(url))
        );
        
        const stillCached = results.filter(r => r.cached);
        
        if (stillCached.length === 0) {
          console.log('Invalidation verified successfully');
          return true;
        }
        
        console.log(`Attempt ${attempt}: ${stillCached.length} URLs still cached`);
      }
      
      throw new Error('Invalidation verification failed');
    }
    
    patternToTag(pattern) {
      // Convert URL pattern to cache tag
      return pattern
        .replace(/\*/g, '')
        .replace(/\//g, '-')
        .replace(/[^a-zA-Z0-9-]/g, '');
    }
  }
  ```
- [ ] Setup cache tagging
- [ ] Configure purge webhooks
- [ ] Test invalidation speed

### Task 5: Optimize Bandwidth Costs (AC: 5)
- [ ] Implement bandwidth optimization
  ```javascript
  // services/bandwidth-optimizer.js
  class BandwidthOptimizer {
    async optimizeContent(content, request) {
      const optimizations = [];
      
      // 1. Image optimization
      if (this.isImage(content.type)) {
        const optimized = await this.optimizeImage(content, request);
        optimizations.push({
          type: 'image',
          original: content.size,
          optimized: optimized.size,
          savings: content.size - optimized.size
        });
        content = optimized;
      }
      
      // 2. Compression
      const acceptEncoding = request.headers['accept-encoding'] || '';
      if (acceptEncoding.includes('br')) {
        content = await this.brotliCompress(content);
        optimizations.push({ type: 'brotli', ratio: 0.7 });
      } else if (acceptEncoding.includes('gzip')) {
        content = await this.gzipCompress(content);
        optimizations.push({ type: 'gzip', ratio: 0.8 });
      }
      
      // 3. Minification
      if (this.canMinify(content.type)) {
        const minified = await this.minify(content);
        optimizations.push({
          type: 'minify',
          original: content.size,
          minified: minified.size
        });
        content = minified;
      }
      
      // 4. Delta encoding for updates
      if (request.headers['if-none-match']) {
        const delta = await this.generateDelta(content, request.headers['if-none-match']);
        if (delta && delta.size < content.size * 0.3) {
          content = delta;
          optimizations.push({ type: 'delta', ratio: delta.size / content.size });
        }
      }
      
      return { content, optimizations };
    }
    
    async optimizeImage(image, request) {
      const options = {
        format: this.selectImageFormat(request),
        quality: this.selectQuality(request),
        width: request.query.w,
        height: request.query.h
      };
      
      // Use Sharp for image processing
      const sharp = require('sharp');
      let pipeline = sharp(image.buffer);
      
      // Resize if requested
      if (options.width || options.height) {
        pipeline = pipeline.resize(options.width, options.height, {
          fit: 'inside',
          withoutEnlargement: true
        });
      }
      
      // Convert format
      switch (options.format) {
        case 'webp':
          pipeline = pipeline.webp({ quality: options.quality });
          break;
        case 'avif':
          pipeline = pipeline.avif({ quality: options.quality });
          break;
        case 'jpeg':
          pipeline = pipeline.jpeg({ 
            quality: options.quality,
            progressive: true 
          });
          break;
      }
      
      const optimized = await pipeline.toBuffer();
      
      return {
        buffer: optimized,
        size: optimized.length,
        type: `image/${options.format}`
      };
    }
    
    selectImageFormat(request) {
      const accept = request.headers.accept || '';
      
      if (accept.includes('image/avif')) {
        return 'avif';
      }
      if (accept.includes('image/webp')) {
        return 'webp';
      }
      return 'jpeg';
    }
    
    async calculateSavings() {
      const metrics = await this.getMetrics();
      
      return {
        totalBandwidth: metrics.bandwidth.total,
        optimizedBandwidth: metrics.bandwidth.optimized,
        savings: metrics.bandwidth.total - metrics.bandwidth.optimized,
        savingsPercent: ((metrics.bandwidth.total - metrics.bandwidth.optimized) / metrics.bandwidth.total) * 100,
        estimatedCostSavings: this.calculateCostSavings(metrics)
      };
    }
  }
  ```
- [ ] Setup tiered caching
- [ ] Configure peering agreements
- [ ] Monitor bandwidth usage

### Task 6: Implement Cache Warming (AC: 6)
- [ ] Create cache warming service
  ```javascript
  // services/cache-warmer.js
  class CacheWarmer {
    constructor() {
      this.criticalPaths = [
        '/',
        '/login',
        '/dashboard',
        '/api/config',
        '/api/user/profile'
      ];
      this.warmingQueue = [];
    }
    
    async warmCache(deployment) {
      console.log(`Starting cache warming for deployment ${deployment.id}`);
      
      const warmingJob = {
        id: this.generateId(),
        deployment: deployment.id,
        startTime: Date.now(),
        urls: [],
        status: 'warming'
      };
      
      this.warmingQueue.push(warmingJob);
      
      try {
        // 1. Warm critical paths
        await this.warmPaths(this.criticalPaths, warmingJob);
        
        // 2. Warm popular content
        const popularContent = await this.getPopularContent();
        await this.warmPaths(popularContent, warmingJob);
        
        // 3. Warm user segments
        await this.warmUserSegments(warmingJob);
        
        // 4. Warm geo-specific content
        await this.warmGeoContent(warmingJob);
        
        // 5. Pre-generate expensive computations
        await this.warmComputations(warmingJob);
        
        warmingJob.endTime = Date.now();
        warmingJob.duration = warmingJob.endTime - warmingJob.startTime;
        warmingJob.status = 'completed';
        warmingJob.urlsWarmed = warmingJob.urls.length;
        
        console.log(`Cache warming completed: ${warmingJob.urlsWarmed} URLs in ${warmingJob.duration}ms`);
        
        return warmingJob;
      } catch (error) {
        warmingJob.status = 'failed';
        warmingJob.error = error.message;
        throw error;
      }
    }
    
    async warmPaths(paths, job) {
      const edgeLocations = await this.getEdgeLocations();
      
      // Warm each path at each edge location
      const promises = [];
      for (const path of paths) {
        for (const location of edgeLocations) {
          promises.push(this.warmUrl(path, location, job));
        }
      }
      
      // Batch requests to avoid overwhelming origins
      const batchSize = 10;
      for (let i = 0; i < promises.length; i += batchSize) {
        const batch = promises.slice(i, i + batchSize);
        await Promise.all(batch);
        await this.sleep(100); // Small delay between batches
      }
    }
    
    async warmUrl(url, location, job) {
      try {
        const response = await fetch(`${location.endpoint}${url}`, {
          headers: {
            'X-Cache-Warm': 'true',
            'X-Edge-Location': location.code
          }
        });
        
        job.urls.push({
          url,
          location: location.code,
          status: response.status,
          cached: response.headers.get('X-Cache') === 'HIT'
        });
        
        return response;
      } catch (error) {
        console.error(`Failed to warm ${url} at ${location.code}:`, error);
      }
    }
    
    async warmUserSegments(job) {
      const segments = ['free', 'premium', 'enterprise'];
      const segmentPaths = ['/dashboard', '/features', '/pricing'];
      
      for (const segment of segments) {
        for (const path of segmentPaths) {
          await this.warmUrl(path, {
            endpoint: this.getPrimaryEndpoint(),
            code: 'primary'
          }, job, {
            'X-User-Segment': segment
          });
        }
      }
    }
    
    async scheduleWarming() {
      // Warm cache before peak hours
      const schedule = [
        { hour: 6, timezone: 'America/New_York' },
        { hour: 6, timezone: 'Europe/London' },
        { hour: 6, timezone: 'Asia/Tokyo' }
      ];
      
      schedule.forEach(s => {
        this.scheduleDaily(s.hour, s.timezone, () => {
          this.warmCache({ id: 'scheduled', trigger: 'daily' });
        });
      });
    }
  }
  ```
- [ ] Setup predictive warming
- [ ] Configure warming schedules
- [ ] Test warming effectiveness

### Task 7: Enable A/B Testing at Edge (AC: 7)
- [ ] Implement edge A/B testing
  ```javascript
  // edge-workers/ab-testing.js
  class EdgeABTesting {
    async handleRequest(request) {
      const experiment = await this.getActiveExperiment(request.url);
      
      if (!experiment) {
        return fetch(request);
      }
      
      // Get or assign variant
      const variant = await this.getVariant(request, experiment);
      
      // Route to variant
      const response = await this.routeToVariant(request, variant);
      
      // Track impression
      this.trackImpression(experiment, variant, request);
      
      // Add variant headers
      response.headers.set('X-Experiment', experiment.id);
      response.headers.set('X-Variant', variant.id);
      
      return response;
    }
    
    async getVariant(request, experiment) {
      // Check for existing assignment
      const cookieVariant = this.getVariantFromCookie(request);
      if (cookieVariant && experiment.variants[cookieVariant]) {
        return experiment.variants[cookieVariant];
      }
      
      // Assign based on traffic allocation
      const variant = this.assignVariant(experiment, request);
      
      // Persist assignment
      this.setVariantCookie(variant.id);
      
      return variant;
    }
    
    assignVariant(experiment, request) {
      const hash = this.hashUser(request);
      const bucket = hash % 100;
      
      let cumulative = 0;
      for (const variant of experiment.variants) {
        cumulative += variant.traffic;
        if (bucket < cumulative) {
          return variant;
        }
      }
      
      return experiment.variants[0]; // Default to control
    }
    
    async routeToVariant(request, variant) {
      if (variant.type === 'redirect') {
        return Response.redirect(variant.url, 302);
      }
      
      if (variant.type === 'proxy') {
        const modifiedRequest = new Request(variant.url, request);
        return fetch(modifiedRequest);
      }
      
      if (variant.type === 'transform') {
        const response = await fetch(request);
        return this.transformResponse(response, variant.transformations);
      }
      
      return fetch(request);
    }
    
    async transformResponse(response, transformations) {
      let body = await response.text();
      
      for (const transform of transformations) {
        switch (transform.type) {
          case 'replace':
            body = body.replace(transform.search, transform.replace);
            break;
          
          case 'inject':
            body = this.injectContent(body, transform);
            break;
          
          case 'remove':
            body = this.removeContent(body, transform);
            break;
        }
      }
      
      return new Response(body, response);
    }
  }
  ```
- [ ] Configure experiment distribution
- [ ] Setup metrics collection
- [ ] Test variant routing

### Task 8: Create Cache Analytics (AC: 8)
- [ ] Build analytics dashboard
  ```javascript
  // services/cache-analytics.js
  class CacheAnalytics {
    async collectMetrics() {
      const metrics = {
        timestamp: new Date(),
        hitRatio: await this.calculateHitRatio(),
        bandwidth: await this.getBandwidthMetrics(),
        latency: await this.getLatencyMetrics(),
        invalidations: await this.getInvalidationMetrics(),
        costs: await this.calculateCosts()
      };
      
      return metrics;
    }
    
    async calculateHitRatio() {
      const stats = await this.aggregateEdgeStats();
      
      return {
        overall: (stats.hits / (stats.hits + stats.misses)) * 100,
        byContentType: {
          static: stats.static.hitRatio,
          dynamic: stats.dynamic.hitRatio,
          api: stats.api.hitRatio
        },
        byRegion: Object.entries(stats.regions).map(([region, data]) => ({
          region,
          hitRatio: (data.hits / (data.hits + data.misses)) * 100
        })),
        trend: await this.getHitRatioTrend()
      };
    }
    
    async generateReport() {
      const report = {
        period: {
          start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          end: new Date()
        },
        performance: {
          avgHitRatio: await this.getAverageHitRatio(),
          p95Latency: await this.getP95Latency(),
          bandwidthSaved: await this.getBandwidthSavings(),
          costSavings: await this.getCostSavings()
        },
        recommendations: await this.generateRecommendations(),
        topContent: await this.getTopCachedContent(),
        misses: await this.analyzeCacheMisses()
      };
      
      return report;
    }
    
    async generateRecommendations() {
      const recommendations = [];
      const metrics = await this.collectMetrics();
      
      if (metrics.hitRatio.overall < 80) {
        recommendations.push({
          priority: 'high',
          issue: 'Low cache hit ratio',
          recommendation: 'Review cache headers and TTL settings',
          impact: 'Could save $' + (metrics.costs.current * 0.2).toFixed(2) + '/month'
        });
      }
      
      const missPatterns = await this.analyzeMissPatterns();
      if (missPatterns.length > 0) {
        recommendations.push({
          priority: 'medium',
          issue: 'Cacheable content not being cached',
          recommendation: `Add cache rules for: ${missPatterns.join(', ')}`,
          impact: 'Reduce origin load by 30%'
        });
      }
      
      return recommendations;
    }
  }
  ```
- [ ] Setup real-time dashboards
- [ ] Configure alerting
- [ ] Create performance reports

---

## Dev Notes

### Edge Locations
```
North America: 25 PoPs
Europe: 20 PoPs
Asia Pacific: 15 PoPs
South America: 5 PoPs
Africa: 3 PoPs
```

### Cache Configuration
```
Static Assets: 30 days, immutable
CSS/JS: 7 days with versioning
API Responses: 60 seconds
User Content: 5 minutes with validation
```

### Cache Key Structure
```
{protocol}:{host}:{path}:{query}:{headers}:{user_segment}
Example: https:oversight.com:/api/data:v=2:accept=json:premium
```

### Performance Targets
- Hit Ratio: > 85%
- TTFB: < 50ms from edge
- Invalidation: < 30 seconds global
- Bandwidth Reduction: > 60%

### Testing Standards
- Test location: `/tests/distribution/edge-cache/`
- Test cache hit ratios
- Verify invalidation speed
- Test personalization caching
- Monitor bandwidth savings

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_