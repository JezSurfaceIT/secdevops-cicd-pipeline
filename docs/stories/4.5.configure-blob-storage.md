# Story 4.5: Configure Blob Storage

**Epic:** 4 - Production SaaS Deployment  
**Story Number:** 4.5  
**Title:** Setup Azure Blob Storage for File Management  
**Status:** READY  
**Points:** 3  
**Component:** 712 (Blob Storage)  

---

## Story

**As a** Data Engineer,  
**I want** scalable blob storage for files and media,  
**so that** we can efficiently store and serve user uploads, documents, and static assets.

---

## Acceptance Criteria

1. Storage account with Standard_GRS redundancy
2. Containers for different file types configured
3. Private endpoint in subnet 10.20.4.0/24
4. CDN integration for static content delivery
5. Lifecycle management policies configured
6. Soft delete and versioning enabled
7. SAS token generation implemented
8. Encryption at rest with customer-managed keys

---

## Tasks / Subtasks

### Task 1: Write Storage Tests (TDD) (AC: 1, 3, 6)
- [ ] Create `production/storage_test.go`
  - [ ] Test storage account exists
  - [ ] Test containers created
  - [ ] Test private endpoint works
  - [ ] Test upload/download operations
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Create Storage Infrastructure (AC: 1, 2)
- [ ] Deploy storage account
  ```hcl
  resource "azurerm_storage_account" "main" {
    name                     = "stoversightprod"
    resource_group_name      = "rg-oversight-prod-saas-eastus"
    location                 = var.location
    account_tier             = "Standard"
    account_replication_type = "GRS"  # Geo-redundant
    account_kind            = "StorageV2"
    
    # Security
    min_tls_version                 = "TLS1_2"
    enable_https_traffic_only       = true
    allow_nested_items_to_be_public = false
    shared_access_key_enabled       = true
    
    # Network
    network_rules {
      default_action = "Deny"
      bypass        = ["AzureServices"]
      
      virtual_network_subnet_ids = [
        azurerm_subnet.saas_storage.id,
        azurerm_subnet.saas_app.id
      ]
      
      ip_rules = []  # No public IPs
    }
    
    # Blob properties
    blob_properties {
      cors_rule {
        allowed_origins    = ["https://app.oversight.com"]
        allowed_methods    = ["GET", "HEAD", "POST", "PUT", "OPTIONS"]
        allowed_headers    = ["*"]
        exposed_headers    = ["*"]
        max_age_in_seconds = 3600
      }
      
      delete_retention_policy {
        days = 30
      }
      
      versioning_enabled = true
      
      container_delete_retention_policy {
        days = 7
      }
    }
    
    # Encryption
    identity {
      type = "SystemAssigned"
    }
    
    encryption {
      services {
        blob {
          enabled = true
          key_type = "Account"
        }
        file {
          enabled = true
          key_type = "Account"
        }
      }
      key_source = "Microsoft.Keyvault"
    }
    
    tags = {
      environment = "production"
      component   = "storage"
    }
  }
  
  # Create containers
  resource "azurerm_storage_container" "containers" {
    for_each = {
      uploads     = "private"
      documents   = "private"
      images      = "blob"  # CDN access
      thumbnails  = "blob"  # CDN access
      backups     = "private"
      logs        = "private"
      temp        = "private"
    }
    
    name                  = each.key
    storage_account_name  = azurerm_storage_account.main.name
    container_access_type = each.value
  }
  ```
- [ ] Configure storage analytics
- [ ] Setup redundancy
- [ ] Enable threat protection

### Task 3: Configure Private Endpoint (AC: 3)
- [ ] Create private endpoint
  ```hcl
  resource "azurerm_private_endpoint" "storage_blob" {
    name                = "pe-storage-blob"
    location            = var.location
    resource_group_name = "rg-oversight-prod-saas-eastus"
    subnet_id           = azurerm_subnet.saas_storage.id
    
    private_service_connection {
      name                           = "psc-storage-blob"
      private_connection_resource_id = azurerm_storage_account.main.id
      subresource_names             = ["blob"]
      is_manual_connection          = false
    }
    
    private_dns_zone_group {
      name                 = "pdz-group-storage"
      private_dns_zone_ids = [azurerm_private_dns_zone.storage_blob.id]
    }
  }
  
  resource "azurerm_private_dns_zone" "storage_blob" {
    name                = "privatelink.blob.core.windows.net"
    resource_group_name = "rg-oversight-prod-saas-eastus"
  }
  ```
- [ ] Test private access
- [ ] Configure DNS
- [ ] Disable public access

### Task 4: Setup CDN Integration (AC: 4)
- [ ] Configure Azure CDN
  ```hcl
  resource "azurerm_cdn_profile" "main" {
    name                = "cdn-oversight"
    location            = "global"
    resource_group_name = "rg-oversight-prod-saas-eastus"
    sku                = "Standard_Microsoft"
  }
  
  resource "azurerm_cdn_endpoint" "static" {
    name                = "cdn-oversight-static"
    profile_name        = azurerm_cdn_profile.main.name
    location            = azurerm_cdn_profile.main.location
    resource_group_name = "rg-oversight-prod-saas-eastus"
    
    origin {
      name      = "storage"
      host_name = azurerm_storage_account.main.primary_blob_endpoint
    }
    
    is_http_allowed    = false
    is_https_allowed   = true
    is_compression_enabled = true
    
    content_types_to_compress = [
      "text/html",
      "text/css",
      "text/javascript",
      "application/javascript",
      "application/json",
      "image/svg+xml"
    ]
    
    global_delivery_rule {
      cache_expiration_action {
        behavior = "SetIfMissing"
        duration = "7.00:00:00"
      }
      
      url_rewrite_action {
        source_pattern = "/cdn/*"
        destination    = "/images/"
        preserve_unmatched_path = false
      }
    }
    
    delivery_rule {
      name  = "EnforceHTTPS"
      order = 1
      
      request_scheme_condition {
        operator     = "Equal"
        match_values = ["HTTP"]
      }
      
      url_redirect_action {
        redirect_type = "PermanentRedirect"
        protocol      = "Https"
      }
    }
  }
  ```
- [ ] Configure caching rules
- [ ] Setup custom domain
- [ ] Test CDN performance

### Task 5: Implement Lifecycle Management (AC: 5)
- [ ] Create lifecycle policies
  ```hcl
  resource "azurerm_storage_management_policy" "lifecycle" {
    storage_account_id = azurerm_storage_account.main.id
    
    rule {
      name    = "archiveoldfiles"
      enabled = true
      
      filters {
        prefix_match = ["uploads/"]
        blob_types   = ["blockBlob"]
      }
      
      actions {
        base_blob {
          tier_to_cool_after_days_since_modification_greater_than = 30
          tier_to_archive_after_days_since_modification_greater_than = 90
          delete_after_days_since_modification_greater_than = 365
        }
        
        snapshot {
          delete_after_days_since_creation_greater_than = 90
        }
        
        version {
          delete_after_days_since_creation = 90
        }
      }
    }
    
    rule {
      name    = "deletetemp"
      enabled = true
      
      filters {
        prefix_match = ["temp/"]
        blob_types   = ["blockBlob"]
      }
      
      actions {
        base_blob {
          delete_after_days_since_modification_greater_than = 7
        }
      }
    }
    
    rule {
      name    = "movelogstoarchive"
      enabled = true
      
      filters {
        prefix_match = ["logs/"]
        blob_types   = ["blockBlob"]
      }
      
      actions {
        base_blob {
          tier_to_cool_after_days_since_modification_greater_than = 7
          tier_to_archive_after_days_since_modification_greater_than = 30
        }
      }
    }
  }
  ```
- [ ] Configure retention policies
- [ ] Setup automatic cleanup
- [ ] Test lifecycle transitions

### Task 6: Implement File Service (AC: 6, 7)
- [ ] Create blob service client
  ```javascript
  // services/blob-storage.js
  const { BlobServiceClient } = require('@azure/storage-blob');
  const { DefaultAzureCredential } = require('@azure/identity');
  const crypto = require('crypto');
  
  class BlobStorageService {
    constructor() {
      this.serviceClient = null;
      this.containers = {};
    }
    
    async initialize() {
      const accountName = process.env.STORAGE_ACCOUNT_NAME;
      const credential = new DefaultAzureCredential();
      
      this.serviceClient = new BlobServiceClient(
        `https://${accountName}.blob.core.windows.net`,
        credential
      );
      
      // Initialize container clients
      const containerNames = ['uploads', 'documents', 'images', 'thumbnails'];
      for (const name of containerNames) {
        this.containers[name] = this.serviceClient.getContainerClient(name);
      }
    }
    
    async uploadFile(containerName, file, metadata = {}) {
      const container = this.containers[containerName];
      const blobName = this.generateBlobName(file.originalname);
      const blockBlobClient = container.getBlockBlobClient(blobName);
      
      // Upload with metadata
      const uploadOptions = {
        blobHTTPHeaders: {
          blobContentType: file.mimetype,
          blobContentDisposition: `attachment; filename="${file.originalname}"`
        },
        metadata: {
          ...metadata,
          uploadedBy: metadata.userId,
          uploadedAt: new Date().toISOString(),
          originalName: file.originalname
        }
      };
      
      // Upload with progress tracking
      const uploadResponse = await blockBlobClient.uploadData(
        file.buffer,
        uploadOptions
      );
      
      // Generate SAS token for private access
      const sasUrl = await this.generateSasUrl(containerName, blobName);
      
      return {
        blobName,
        url: blockBlobClient.url,
        sasUrl,
        etag: uploadResponse.etag,
        contentMD5: uploadResponse.contentMD5,
        size: file.size
      };
    }
    
    async generateSasUrl(containerName, blobName, options = {}) {
      const { 
        permissions = 'r',  // Read only
        expiresIn = 3600    // 1 hour
      } = options;
      
      const sasToken = await this.generateSasToken(
        containerName,
        blobName,
        permissions,
        expiresIn
      );
      
      const container = this.containers[containerName];
      const blobClient = container.getBlockBlobClient(blobName);
      
      return `${blobClient.url}?${sasToken}`;
    }
    
    async generateSasToken(containerName, blobName, permissions, expiresIn) {
      const startsOn = new Date();
      const expiresOn = new Date(startsOn.getTime() + expiresIn * 1000);
      
      // This would typically use account key from Key Vault
      const accountKey = await secretManager.getSecret('storage-account-key');
      
      const sasOptions = {
        containerName,
        blobName,
        permissions,
        startsOn,
        expiresOn,
        ipRange: { start: '0.0.0.0', end: '255.255.255.255' },
        protocol: 'https'
      };
      
      // Generate SAS token
      return generateBlobSASQueryParameters(sasOptions, accountKey).toString();
    }
    
    async downloadFile(containerName, blobName) {
      const container = this.containers[containerName];
      const blobClient = container.getBlockBlobClient(blobName);
      
      const downloadResponse = await blobClient.download();
      
      return {
        stream: downloadResponse.readableStreamBody,
        contentType: downloadResponse.contentType,
        contentLength: downloadResponse.contentLength,
        metadata: downloadResponse.metadata
      };
    }
    
    async deleteFile(containerName, blobName) {
      const container = this.containers[containerName];
      const blobClient = container.getBlockBlobClient(blobName);
      
      // Soft delete (can be recovered within retention period)
      await blobClient.delete({
        deleteSnapshots: 'include'
      });
    }
    
    async listFiles(containerName, prefix = '', limit = 100) {
      const container = this.containers[containerName];
      const files = [];
      
      for await (const blob of container.listBlobsFlat({ prefix })) {
        files.push({
          name: blob.name,
          size: blob.properties.contentLength,
          contentType: blob.properties.contentType,
          lastModified: blob.properties.lastModified,
          etag: blob.properties.etag
        });
        
        if (files.length >= limit) break;
      }
      
      return files;
    }
    
    generateBlobName(originalName) {
      const ext = originalName.split('.').pop();
      const hash = crypto.randomBytes(16).toString('hex');
      const timestamp = Date.now();
      return `${timestamp}-${hash}.${ext}`;
    }
  }
  
  module.exports = new BlobStorageService();
  ```
- [ ] Implement versioning
- [ ] Setup soft delete
- [ ] Configure access tiers

### Task 7: Configure Encryption (AC: 8)
- [ ] Setup customer-managed keys
  ```hcl
  resource "azurerm_key_vault_key" "storage" {
    name         = "storage-encryption-key"
    key_vault_id = azurerm_key_vault.main.id
    key_type     = "RSA"
    key_size     = 2048
    
    key_opts = [
      "decrypt",
      "encrypt",
      "sign",
      "unwrapKey",
      "verify",
      "wrapKey"
    ]
  }
  
  resource "azurerm_storage_account_customer_managed_key" "main" {
    storage_account_id = azurerm_storage_account.main.id
    key_vault_id       = azurerm_key_vault.main.id
    key_name          = azurerm_key_vault_key.storage.name
  }
  ```
- [ ] Configure encryption scopes
- [ ] Setup key rotation
- [ ] Test encryption

### Task 8: Implement Monitoring (AC: 1)
- [ ] Configure diagnostics
  ```hcl
  resource "azurerm_monitor_diagnostic_setting" "storage" {
    name               = "diag-storage"
    target_resource_id = "${azurerm_storage_account.main.id}/blobServices/default"
    
    log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id
    
    enabled_log {
      category = "StorageRead"
    }
    
    enabled_log {
      category = "StorageWrite"
    }
    
    enabled_log {
      category = "StorageDelete"
    }
    
    metric {
      category = "Transaction"
    }
    
    metric {
      category = "Capacity"
    }
  }
  ```
- [ ] Create monitoring dashboard
- [ ] Setup alerts
- [ ] Track usage metrics

---

## Dev Notes

### Storage Endpoints
```
Blob: https://stoversightprod.blob.core.windows.net
Private: https://stoversightprod.privatelink.blob.core.windows.net
CDN: https://cdn-oversight-static.azureedge.net
```

### Container Structure
```
/uploads       - User uploaded files
/documents     - PDFs, docs, spreadsheets
/images        - Product images, avatars
/thumbnails    - Generated thumbnails
/backups       - Database and app backups
/logs          - Application logs
/temp          - Temporary files (auto-cleanup)
```

### Testing Standards
- Test location: `/tests/production/storage/`
- Test upload/download operations
- Verify SAS token generation
- Test lifecycle policies
- Monitor storage costs

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_