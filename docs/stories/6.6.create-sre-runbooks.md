# Story 6.6: Create SRE Runbooks

**Epic:** 6 - Monitoring & Observability  
**Story Number:** 6.6  
**Title:** Develop Automated Runbooks for Common Incidents  
**Status:** READY  
**Points:** 3  
**Component:** 925 (SRE Runbooks)  

---

## Story

**As an** SRE Engineer,  
**I want** automated runbooks for common operational issues,  
**so that** we can quickly resolve incidents and reduce MTTR.

---

## Acceptance Criteria

1. Runbook automation platform deployed
2. 20+ common incident runbooks created
3. Self-healing capabilities implemented
4. Runbook execution tracking and audit
5. Integration with alert system
6. Approval workflows for destructive actions
7. Rollback mechanisms in place
8. Documentation auto-generated from runbooks

---

## Tasks / Subtasks

### Task 1: Write Runbook Tests (TDD) (AC: 1, 3, 4)
- [ ] Create `sre/runbook_test.go`
  - [ ] Test runbook execution
  - [ ] Test self-healing actions
  - [ ] Test rollback mechanisms
  - [ ] Test audit logging
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Setup Runbook Platform (AC: 1, 4)
- [ ] Deploy runbook automation system
  ```yaml
  # runbook-operator/deployment.yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: runbook-operator
    namespace: sre
  spec:
    replicas: 2
    selector:
      matchLabels:
        app: runbook-operator
    template:
      metadata:
        labels:
          app: runbook-operator
      spec:
        serviceAccountName: runbook-operator
        containers:
        - name: operator
          image: oversight/runbook-operator:v1.0.0
          env:
          - name: OPERATOR_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: ALERTMANAGER_URL
            value: http://alertmanager:9093
          - name: SLACK_WEBHOOK
            valueFrom:
              secretKeyRef:
                name: runbook-secrets
                key: slack-webhook
          - name: APPROVAL_TIMEOUT
            value: "300"
          ports:
          - containerPort: 8080
            name: http
          - containerPort: 9090
            name: metrics
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
  
  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: runbook-operator
    namespace: sre
  spec:
    selector:
      app: runbook-operator
    ports:
    - name: http
      port: 8080
      targetPort: 8080
    - name: metrics
      port: 9090
      targetPort: 9090
  
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    name: runbook-operator
  rules:
  - apiGroups: [""]
    resources: ["pods", "services", "nodes", "configmaps", "secrets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets", "daemonsets", "replicasets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete", "scale"]
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["networkpolicies", "ingresses"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
  - apiGroups: ["sre.oversight.io"]
    resources: ["runbooks", "runbookexecutions"]
    verbs: ["*"]
  ```
- [ ] Create runbook CRD
  ```yaml
  # runbook-crd.yaml
  apiVersion: apiextensions.k8s.io/v1
  kind: CustomResourceDefinition
  metadata:
    name: runbooks.sre.oversight.io
  spec:
    group: sre.oversight.io
    versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                name:
                  type: string
                description:
                  type: string
                trigger:
                  type: object
                  properties:
                    alert:
                      type: string
                    manual:
                      type: boolean
                    schedule:
                      type: string
                approval:
                  type: object
                  properties:
                    required:
                      type: boolean
                    approvers:
                      type: array
                      items:
                        type: string
                    timeout:
                      type: integer
                steps:
                  type: array
                  items:
                    type: object
                    properties:
                      name:
                        type: string
                      action:
                        type: string
                      parameters:
                        type: object
                      validation:
                        type: object
                      rollback:
                        type: object
                      retries:
                        type: integer
                      timeout:
                        type: integer
                documentation:
                  type: object
                  properties:
                    symptoms:
                      type: array
                      items:
                        type: string
                    impact:
                      type: string
                    resolution:
                      type: string
            status:
              type: object
              properties:
                lastExecution:
                  type: string
                executions:
                  type: integer
                successRate:
                  type: number
                averageDuration:
                  type: integer
    scope: Namespaced
    names:
      plural: runbooks
      singular: runbook
      kind: Runbook
  ```
- [ ] Setup execution engine
  ```javascript
  // services/runbook-executor.js
  const k8s = require('@kubernetes/client-node');
  const { VM } = require('vm2');
  
  class RunbookExecutor {
    constructor() {
      this.kc = new k8s.KubeConfig();
      this.kc.loadFromDefault();
      this.k8sApi = this.kc.makeApiClient(k8s.CoreV1Api);
      this.k8sAppsApi = this.kc.makeApiClient(k8s.AppsV1Api);
      this.executions = new Map();
    }
    
    async executeRunbook(runbook, context) {
      const executionId = this.generateExecutionId();
      const execution = {
        id: executionId,
        runbook: runbook.metadata.name,
        startTime: new Date(),
        context,
        steps: [],
        status: 'running'
      };
      
      this.executions.set(executionId, execution);
      
      try {
        // Check if approval needed
        if (runbook.spec.approval?.required) {
          await this.requestApproval(runbook, execution);
        }
        
        // Execute steps
        for (const step of runbook.spec.steps) {
          const stepResult = await this.executeStep(step, context, execution);
          execution.steps.push(stepResult);
          
          if (!stepResult.success && !step.continueOnError) {
            throw new Error(`Step ${step.name} failed: ${stepResult.error}`);
          }
        }
        
        execution.status = 'completed';
        execution.endTime = new Date();
        
        // Update metrics
        await this.updateMetrics(runbook, execution);
        
        // Send notification
        await this.notifyCompletion(runbook, execution);
        
        return execution;
      } catch (error) {
        execution.status = 'failed';
        execution.error = error.message;
        execution.endTime = new Date();
        
        // Attempt rollback
        if (runbook.spec.rollbackOnFailure) {
          await this.rollback(execution);
        }
        
        // Send failure notification
        await this.notifyFailure(runbook, execution, error);
        
        throw error;
      }
    }
    
    async executeStep(step, context, execution) {
      const startTime = Date.now();
      const result = {
        name: step.name,
        startTime: new Date(),
        action: step.action
      };
      
      try {
        // Validate prerequisites
        if (step.validation?.prerequisite) {
          const valid = await this.validatePrerequisite(step.validation.prerequisite, context);
          if (!valid) {
            throw new Error('Prerequisite validation failed');
          }
        }
        
        // Execute action
        const actionResult = await this.executeAction(step.action, step.parameters, context);
        result.output = actionResult;
        
        // Validate result
        if (step.validation?.postCondition) {
          const valid = await this.validatePostCondition(step.validation.postCondition, actionResult);
          if (!valid) {
            throw new Error('Post-condition validation failed');
          }
        }
        
        result.success = true;
        result.duration = Date.now() - startTime;
      } catch (error) {
        result.success = false;
        result.error = error.message;
        result.duration = Date.now() - startTime;
        
        // Retry logic
        if (step.retries > 0) {
          console.log(`Retrying step ${step.name}, attempts remaining: ${step.retries}`);
          await this.sleep(5000);
          step.retries--;
          return await this.executeStep(step, context, execution);
        }
      }
      
      result.endTime = new Date();
      return result;
    }
    
    async executeAction(action, parameters, context) {
      const actions = {
        'kubernetes.restart_pod': async (params) => {
          await this.k8sApi.deleteNamespacedPod(
            params.podName,
            params.namespace || 'default'
          );
          return { restarted: true };
        },
        
        'kubernetes.scale_deployment': async (params) => {
          const patch = { spec: { replicas: params.replicas } };
          await this.k8sAppsApi.patchNamespacedDeployment(
            params.deployment,
            params.namespace || 'default',
            patch,
            undefined, undefined, undefined, undefined,
            { headers: { 'Content-Type': 'application/merge-patch+json' } }
          );
          return { scaled: true, replicas: params.replicas };
        },
        
        'kubernetes.cordon_node': async (params) => {
          const patch = { spec: { unschedulable: true } };
          await this.k8sApi.patchNode(
            params.nodeName,
            patch,
            undefined, undefined, undefined, undefined,
            { headers: { 'Content-Type': 'application/merge-patch+json' } }
          );
          return { cordoned: true };
        },
        
        'kubernetes.drain_node': async (params) => {
          // Cordon first
          await actions['kubernetes.cordon_node'](params);
          
          // Get pods on node
          const pods = await this.k8sApi.listPodForAllNamespaces(
            undefined, undefined, undefined,
            `spec.nodeName=${params.nodeName}`
          );
          
          // Evict pods
          for (const pod of pods.body.items) {
            if (!pod.metadata.ownerReferences) continue; // Skip standalone pods
            
            await this.k8sApi.createNamespacedPodEviction(
              pod.metadata.name,
              pod.metadata.namespace,
              { apiVersion: 'policy/v1beta1', kind: 'Eviction' }
            );
          }
          
          return { drained: true, podsEvicted: pods.body.items.length };
        },
        
        'database.vacuum': async (params) => {
          // Execute vacuum on database
          const pg = require('pg');
          const client = new pg.Client(params.connectionString);
          await client.connect();
          await client.query('VACUUM ANALYZE');
          await client.end();
          return { vacuumed: true };
        },
        
        'cache.flush': async (params) => {
          const redis = require('redis');
          const client = redis.createClient({ url: params.redisUrl });
          await client.connect();
          await client.flushAll();
          await client.quit();
          return { flushed: true };
        },
        
        'http.healthcheck': async (params) => {
          const axios = require('axios');
          const response = await axios.get(params.url, { timeout: 5000 });
          return { healthy: response.status === 200, status: response.status };
        },
        
        'script.execute': async (params) => {
          // Safe script execution
          const vm = new VM({
            timeout: params.timeout || 10000,
            sandbox: { ...context, ...params.variables }
          });
          
          const result = vm.run(params.script);
          return { result };
        }
      };
      
      const actionFn = actions[action];
      if (!actionFn) {
        throw new Error(`Unknown action: ${action}`);
      }
      
      return await actionFn(parameters);
    }
    
    generateExecutionId() {
      return `exec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  }
  ```
- [ ] Configure audit logging
- [ ] Setup metrics collection

### Task 3: Create Infrastructure Runbooks (AC: 2, 3)
- [ ] Pod restart runbook
  ```yaml
  # runbooks/pod-restart.yaml
  apiVersion: sre.oversight.io/v1
  kind: Runbook
  metadata:
    name: pod-restart
    namespace: sre
  spec:
    name: "Pod Restart - OOMKilled"
    description: "Automatically restart pods that are OOMKilled and increase memory limits"
    
    trigger:
      alert: PodOOMKilled
    
    approval:
      required: false
    
    steps:
    - name: identify-pod
      action: kubernetes.get_pod
      parameters:
        podName: "{{ .Alert.Labels.pod }}"
        namespace: "{{ .Alert.Labels.namespace }}"
      validation:
        prerequisite:
          podExists: true
    
    - name: check-restart-count
      action: script.execute
      parameters:
        script: |
          const restartCount = context.pod.status.containerStatuses[0].restartCount;
          if (restartCount > 5) {
            throw new Error('Pod has restarted too many times');
          }
          return { proceed: true };
    
    - name: increase-memory
      action: kubernetes.patch_deployment
      parameters:
        deployment: "{{ .Alert.Labels.deployment }}"
        namespace: "{{ .Alert.Labels.namespace }}"
        patch:
          spec:
            template:
              spec:
                containers:
                - name: "{{ .Alert.Labels.container }}"
                  resources:
                    limits:
                      memory: "{{ multiply .CurrentMemory 1.5 }}"
                    requests:
                      memory: "{{ multiply .CurrentMemory 1.2 }}"
    
    - name: restart-pod
      action: kubernetes.restart_pod
      parameters:
        podName: "{{ .Alert.Labels.pod }}"
        namespace: "{{ .Alert.Labels.namespace }}"
      retries: 2
      timeout: 60
    
    - name: verify-health
      action: http.healthcheck
      parameters:
        url: "http://{{ .Alert.Labels.pod }}.{{ .Alert.Labels.namespace }}:8080/health"
      validation:
        postCondition:
          healthy: true
      retries: 5
      timeout: 30
    
    documentation:
      symptoms:
        - Pod killed due to OOM
        - Container restarts with exit code 137
      impact: Service degradation or unavailability
      resolution: Increase memory limits and restart pod
  ```
- [ ] Node drain runbook
  ```yaml
  # runbooks/node-drain.yaml
  apiVersion: sre.oversight.io/v1
  kind: Runbook
  metadata:
    name: node-drain
    namespace: sre
  spec:
    name: "Node Drain - High Memory Pressure"
    description: "Drain node experiencing memory pressure"
    
    trigger:
      alert: NodeMemoryPressure
    
    approval:
      required: true
      approvers: ["sre-team", "platform-team"]
      timeout: 300
    
    steps:
    - name: check-node-status
      action: kubernetes.get_node
      parameters:
        nodeName: "{{ .Alert.Labels.node }}"
    
    - name: check-workload-count
      action: script.execute
      parameters:
        script: |
          const pods = await kubernetes.listPods({
            fieldSelector: `spec.nodeName=${context.node}`
          });
          if (pods.length > 50) {
            context.requiresGradualDrain = true;
          }
          return { podCount: pods.length };
    
    - name: cordon-node
      action: kubernetes.cordon_node
      parameters:
        nodeName: "{{ .Alert.Labels.node }}"
    
    - name: gradual-drain
      action: kubernetes.drain_node
      parameters:
        nodeName: "{{ .Alert.Labels.node }}"
        gracePeriod: 300
        ignoreDaemonsets: true
        deleteLocalData: false
      timeout: 600
    
    - name: verify-drain
      action: script.execute
      parameters:
        script: |
          const pods = await kubernetes.listPods({
            fieldSelector: `spec.nodeName=${context.node}`
          });
          const nonDaemonsetPods = pods.filter(p => !p.spec.daemonset);
          return { remaining: nonDaemonsetPods.length };
      validation:
        postCondition:
          remaining: 0
    
    rollback:
      steps:
      - name: uncordon-node
        action: kubernetes.uncordon_node
        parameters:
          nodeName: "{{ .Alert.Labels.node }}"
  ```
- [ ] Database maintenance runbook
- [ ] Cache clear runbook
- [ ] Certificate renewal runbook

### Task 4: Create Application Runbooks (AC: 2, 3)
- [ ] High latency runbook
  ```yaml
  # runbooks/high-latency.yaml
  apiVersion: sre.oversight.io/v1
  kind: Runbook
  metadata:
    name: high-latency
    namespace: sre
  spec:
    name: "High Latency Resolution"
    description: "Diagnose and resolve high application latency"
    
    trigger:
      alert: HighLatency
    
    steps:
    - name: check-database-connections
      action: database.check_connections
      parameters:
        host: "{{ .Config.database.host }}"
      validation:
        postCondition:
          connectionCount: "< 80"
    
    - name: check-cache-hit-rate
      action: cache.get_stats
      parameters:
        host: "{{ .Config.redis.host }}"
      validation:
        postCondition:
          hitRate: "> 0.8"
    
    - name: clear-cache-if-needed
      action: script.execute
      parameters:
        script: |
          if (context.cacheHitRate < 0.5) {
            await cache.flush({ pattern: 'session:*' });
            return { cleared: true };
          }
          return { cleared: false };
    
    - name: scale-up-if-needed
      action: script.execute
      parameters:
        script: |
          const cpu = await metrics.getCPU('{{ .Alert.Labels.service }}');
          if (cpu > 80) {
            await kubernetes.scaleDeployment({
              deployment: '{{ .Alert.Labels.service }}',
              replicas: context.currentReplicas + 2
            });
            return { scaled: true };
          }
          return { scaled: false };
    
    - name: enable-circuit-breaker
      action: config.update
      parameters:
        service: "{{ .Alert.Labels.service }}"
        config:
          circuitBreaker:
            enabled: true
            threshold: 50
            timeout: 10000
    
    documentation:
      symptoms:
        - Response time > 1000ms
        - Increased error rate
        - User complaints
      impact: Poor user experience, potential revenue loss
      resolution: Scale resources, clear cache, enable circuit breaker
  ```
- [ ] Error rate spike runbook
  ```yaml
  # runbooks/error-spike.yaml
  apiVersion: sre.oversight.io/v1
  kind: Runbook
  metadata:
    name: error-spike
    namespace: sre
  spec:
    name: "Error Rate Spike"
    description: "Handle sudden increase in error rate"
    
    trigger:
      alert: HighErrorRate
    
    steps:
    - name: get-error-logs
      action: logs.query
      parameters:
        query: |
          {service="{{ .Alert.Labels.service }}"} 
          |= "error" 
          | json 
          | __error__="" 
          [5m]
      
    - name: analyze-errors
      action: script.execute
      parameters:
        script: |
          const errors = context.logs;
          const errorTypes = {};
          errors.forEach(log => {
            const type = log.error?.type || 'unknown';
            errorTypes[type] = (errorTypes[type] || 0) + 1;
          });
          
          const mostCommon = Object.entries(errorTypes)
            .sort((a, b) => b[1] - a[1])[0];
          
          context.primaryError = mostCommon[0];
          context.errorCount = mostCommon[1];
          
          return { primaryError: mostCommon[0], count: mostCommon[1] };
    
    - name: check-dependencies
      action: http.healthcheck_batch
      parameters:
        urls:
          - "{{ .Config.database.healthUrl }}"
          - "{{ .Config.redis.healthUrl }}"
          - "{{ .Config.authService.healthUrl }}"
    
    - name: rollback-if-recent-deployment
      action: script.execute
      parameters:
        script: |
          const deployments = await kubernetes.getDeploymentHistory({
            deployment: '{{ .Alert.Labels.service }}',
            limit: 1
          });
          
          const lastDeployment = deployments[0];
          const timeSinceDeploy = Date.now() - lastDeployment.timestamp;
          
          if (timeSinceDeploy < 600000) { // 10 minutes
            await kubernetes.rollbackDeployment({
              deployment: '{{ .Alert.Labels.service }}'
            });
            return { rolledBack: true, revision: lastDeployment.revision };
          }
          return { rolledBack: false };
    
    - name: enable-debug-logging
      action: config.update
      parameters:
        service: "{{ .Alert.Labels.service }}"
        config:
          logging:
            level: "debug"
          metrics:
            detailed: true
      timeout: 30
  ```
- [ ] Memory leak runbook
- [ ] Deployment failure runbook
- [ ] API throttling runbook

### Task 5: Create Security Runbooks (AC: 2, 3)
- [ ] Suspicious activity runbook
  ```yaml
  # runbooks/suspicious-activity.yaml
  apiVersion: sre.oversight.io/v1
  kind: Runbook
  metadata:
    name: suspicious-activity
    namespace: sre
  spec:
    name: "Suspicious Activity Response"
    description: "Respond to detected suspicious activity"
    
    trigger:
      alert: SuspiciousActivity
    
    approval:
      required: true
      approvers: ["security-team"]
      timeout: 60
    
    steps:
    - name: isolate-source
      action: network.block_ip
      parameters:
        ip: "{{ .Alert.Labels.source_ip }}"
        duration: 3600
    
    - name: snapshot-affected-resources
      action: forensics.snapshot
      parameters:
        resources:
          - type: pod
            name: "{{ .Alert.Labels.pod }}"
          - type: volume
            name: "{{ .Alert.Labels.volume }}"
    
    - name: rotate-credentials
      action: security.rotate_credentials
      parameters:
        service: "{{ .Alert.Labels.service }}"
        scope: "all"
    
    - name: enable-enhanced-monitoring
      action: monitoring.enable_detailed
      parameters:
        service: "{{ .Alert.Labels.service }}"
        level: "paranoid"
        duration: 86400
    
    - name: notify-security-team
      action: notification.send
      parameters:
        channel: "security-incidents"
        priority: "high"
        message: |
          Suspicious activity detected and contained:
          - Source: {{ .Alert.Labels.source_ip }}
          - Service: {{ .Alert.Labels.service }}
          - Actions taken: IP blocked, credentials rotated, forensics captured
  ```
- [ ] Brute force runbook
- [ ] Data exfiltration runbook
- [ ] Privilege escalation runbook

### Task 6: Implement Self-Healing (AC: 3, 7)
- [ ] Create self-healing controller
  ```javascript
  // controllers/self-healing.js
  class SelfHealingController {
    constructor(runbookExecutor) {
      this.executor = runbookExecutor;
      this.healingHistory = new Map();
      this.healingPolicies = this.loadPolicies();
    }
    
    async handleAlert(alert) {
      // Check if self-healing is enabled for this alert
      const policy = this.healingPolicies.find(p => 
        p.alertPattern.test(alert.labels.alertname)
      );
      
      if (!policy) {
        console.log(`No self-healing policy for ${alert.labels.alertname}`);
        return null;
      }
      
      // Check healing history to prevent loops
      const historyKey = `${alert.labels.alertname}-${alert.labels.service}`;
      const history = this.healingHistory.get(historyKey) || [];
      
      const recentHealing = history.filter(h => 
        Date.now() - h.timestamp < policy.cooldownPeriod
      );
      
      if (recentHealing.length >= policy.maxAttempts) {
        console.log(`Max healing attempts reached for ${historyKey}`);
        await this.escalate(alert, history);
        return null;
      }
      
      // Execute healing runbook
      try {
        const runbook = await this.loadRunbook(policy.runbook);
        const context = {
          Alert: alert,
          Config: await this.loadConfig(),
          History: history
        };
        
        const execution = await this.executor.executeRunbook(runbook, context);
        
        // Update history
        history.push({
          timestamp: Date.now(),
          executionId: execution.id,
          success: execution.status === 'completed'
        });
        this.healingHistory.set(historyKey, history);
        
        // Verify healing
        if (policy.verification) {
          setTimeout(async () => {
            await this.verifyHealing(alert, execution, policy);
          }, policy.verification.delay);
        }
        
        return execution;
      } catch (error) {
        console.error(`Self-healing failed for ${historyKey}:`, error);
        await this.escalate(alert, history, error);
        return null;
      }
    }
    
    async verifyHealing(alert, execution, policy) {
      const verification = policy.verification;
      
      try {
        const result = await this.executor.executeAction(
          verification.action,
          verification.parameters,
          { alert, execution }
        );
        
        if (!result[verification.expectedResult]) {
          console.log(`Healing verification failed for ${alert.labels.alertname}`);
          await this.escalate(alert, [execution], 'Verification failed');
        } else {
          console.log(`Healing verified for ${alert.labels.alertname}`);
          await this.notifySuccess(alert, execution);
        }
      } catch (error) {
        console.error('Verification error:', error);
        await this.escalate(alert, [execution], error);
      }
    }
    
    loadPolicies() {
      return [
        {
          alertPattern: /PodOOMKilled/,
          runbook: 'pod-restart',
          maxAttempts: 3,
          cooldownPeriod: 3600000, // 1 hour
          verification: {
            delay: 60000, // 1 minute
            action: 'http.healthcheck',
            parameters: { url: '{{ .Service.HealthUrl }}' },
            expectedResult: 'healthy'
          }
        },
        {
          alertPattern: /HighLatency/,
          runbook: 'high-latency',
          maxAttempts: 2,
          cooldownPeriod: 1800000, // 30 minutes
          verification: {
            delay: 120000, // 2 minutes
            action: 'metrics.check',
            parameters: { metric: 'response_time', threshold: 500 },
            expectedResult: 'below_threshold'
          }
        },
        {
          alertPattern: /CertificateExpiring/,
          runbook: 'cert-renewal',
          maxAttempts: 1,
          cooldownPeriod: 86400000, // 24 hours
          verification: {
            delay: 30000,
            action: 'certificate.check',
            parameters: { domain: '{{ .Alert.Labels.domain }}' },
            expectedResult: 'valid'
          }
        }
      ];
    }
  }
  ```
- [ ] Configure rollback mechanisms
- [ ] Setup healing verification
- [ ] Create escalation policies

### Task 7: Setup Approval Workflows (AC: 6)
- [ ] Create approval system
  ```javascript
  // services/approval-service.js
  class ApprovalService {
    constructor() {
      this.pendingApprovals = new Map();
      this.approvalHistory = [];
    }
    
    async requestApproval(runbook, execution) {
      const approval = {
        id: this.generateApprovalId(),
        runbook: runbook.metadata.name,
        execution: execution.id,
        requestedAt: new Date(),
        requestedBy: execution.context.triggeredBy,
        approvers: runbook.spec.approval.approvers,
        timeout: runbook.spec.approval.timeout || 300,
        status: 'pending',
        description: runbook.spec.description,
        impact: this.assessImpact(runbook)
      };
      
      this.pendingApprovals.set(approval.id, approval);
      
      // Send approval requests
      await this.sendApprovalRequests(approval);
      
      // Set timeout
      setTimeout(() => {
        if (approval.status === 'pending') {
          approval.status = 'timeout';
          this.handleTimeout(approval);
        }
      }, approval.timeout * 1000);
      
      // Wait for approval
      return new Promise((resolve, reject) => {
        approval.resolve = resolve;
        approval.reject = reject;
      });
    }
    
    async sendApprovalRequests(approval) {
      // Send Slack message with approval buttons
      const slackMessage = {
        channel: '#sre-approvals',
        text: `Runbook approval requested: ${approval.runbook}`,
        attachments: [{
          color: 'warning',
          title: 'Approval Required',
          text: approval.description,
          fields: [
            { title: 'Runbook', value: approval.runbook, short: true },
            { title: 'Triggered By', value: approval.requestedBy, short: true },
            { title: 'Impact', value: approval.impact, short: true },
            { title: 'Timeout', value: `${approval.timeout}s`, short: true }
          ],
          actions: [
            {
              type: 'button',
              text: 'Approve',
              style: 'primary',
              value: JSON.stringify({ id: approval.id, action: 'approve' })
            },
            {
              type: 'button',
              text: 'Reject',
              style: 'danger',
              value: JSON.stringify({ id: approval.id, action: 'reject' })
            },
            {
              type: 'button',
              text: 'View Details',
              url: `https://sre.oversight.com/approvals/${approval.id}`
            }
          ]
        }]
      };
      
      await this.slack.postMessage(slackMessage);
      
      // Send email to approvers
      for (const approver of approval.approvers) {
        await this.sendEmail({
          to: `${approver}@oversight.com`,
          subject: `[APPROVAL REQUIRED] ${approval.runbook}`,
          body: this.generateApprovalEmail(approval)
        });
      }
    }
    
    async handleApproval(approvalId, approver, action, comment) {
      const approval = this.pendingApprovals.get(approvalId);
      
      if (!approval) {
        throw new Error('Approval not found');
      }
      
      if (approval.status !== 'pending') {
        throw new Error(`Approval already ${approval.status}`);
      }
      
      // Verify approver is authorized
      if (!approval.approvers.includes(approver)) {
        throw new Error('Unauthorized approver');
      }
      
      approval.status = action;
      approval.approvedBy = approver;
      approval.approvedAt = new Date();
      approval.comment = comment;
      
      // Record in history
      this.approvalHistory.push({...approval});
      
      // Remove from pending
      this.pendingApprovals.delete(approvalId);
      
      // Resolve or reject promise
      if (action === 'approve') {
        approval.resolve(approval);
      } else {
        approval.reject(new Error(`Approval rejected by ${approver}: ${comment}`));
      }
      
      // Send notifications
      await this.notifyApprovalResult(approval);
    }
    
    assessImpact(runbook) {
      const highImpactActions = [
        'kubernetes.drain_node',
        'database.failover',
        'service.restart',
        'data.delete'
      ];
      
      const hasHighImpact = runbook.spec.steps.some(step =>
        highImpactActions.includes(step.action)
      );
      
      return hasHighImpact ? 'HIGH' : 'LOW';
    }
  }
  ```
- [ ] Create approval UI
- [ ] Setup notification system
- [ ] Configure audit trail

### Task 8: Generate Documentation (AC: 8)
- [ ] Create documentation generator
  ```javascript
  // services/doc-generator.js
  class RunbookDocGenerator {
    async generateDocs(runbooks) {
      const docs = {
        title: 'SRE Runbook Documentation',
        generatedAt: new Date(),
        runbooks: []
      };
      
      for (const runbook of runbooks) {
        const doc = await this.generateRunbookDoc(runbook);
        docs.runbooks.push(doc);
      }
      
      // Generate markdown
      const markdown = this.generateMarkdown(docs);
      
      // Generate HTML
      const html = this.generateHTML(docs);
      
      // Generate PDF
      const pdf = await this.generatePDF(docs);
      
      return { markdown, html, pdf };
    }
    
    generateRunbookDoc(runbook) {
      return {
        name: runbook.spec.name,
        description: runbook.spec.description,
        trigger: this.describeTrigger(runbook.spec.trigger),
        approval: runbook.spec.approval?.required ? 
          `Requires approval from: ${runbook.spec.approval.approvers.join(', ')}` :
          'No approval required',
        steps: runbook.spec.steps.map(step => ({
          name: step.name,
          action: step.action,
          description: this.describeAction(step.action),
          parameters: step.parameters,
          validation: step.validation,
          retries: step.retries || 0,
          timeout: step.timeout || 'default'
        })),
        documentation: runbook.spec.documentation,
        metrics: this.getRunbookMetrics(runbook.metadata.name)
      };
    }
    
    generateMarkdown(docs) {
      let md = `# ${docs.title}\n\n`;
      md += `Generated: ${docs.generatedAt}\n\n`;
      md += `## Table of Contents\n\n`;
      
      docs.runbooks.forEach((rb, i) => {
        md += `${i + 1}. [${rb.name}](#${rb.name.toLowerCase().replace(/\s/g, '-')})\n`;
      });
      
      md += '\n---\n\n';
      
      docs.runbooks.forEach(rb => {
        md += `## ${rb.name}\n\n`;
        md += `**Description:** ${rb.description}\n\n`;
        md += `**Trigger:** ${rb.trigger}\n\n`;
        md += `**Approval:** ${rb.approval}\n\n`;
        
        md += `### Steps\n\n`;
        rb.steps.forEach((step, i) => {
          md += `${i + 1}. **${step.name}**\n`;
          md += `   - Action: \`${step.action}\`\n`;
          md += `   - ${step.description}\n`;
          if (step.retries > 0) {
            md += `   - Retries: ${step.retries}\n`;
          }
          md += '\n';
        });
        
        if (rb.documentation) {
          md += `### Symptoms\n\n`;
          rb.documentation.symptoms?.forEach(s => {
            md += `- ${s}\n`;
          });
          
          md += `\n### Impact\n\n${rb.documentation.impact}\n\n`;
          md += `### Resolution\n\n${rb.documentation.resolution}\n\n`;
        }
        
        if (rb.metrics) {
          md += `### Performance Metrics\n\n`;
          md += `- Executions: ${rb.metrics.executions}\n`;
          md += `- Success Rate: ${rb.metrics.successRate}%\n`;
          md += `- Avg Duration: ${rb.metrics.avgDuration}s\n`;
        }
        
        md += '\n---\n\n';
      });
      
      return md;
    }
  }
  ```
- [ ] Setup documentation site
- [ ] Create runbook catalog
- [ ] Generate training materials

---

## Dev Notes

### Runbook Platform
```
API: https://runbooks.oversight.com/api
UI: https://runbooks.oversight.com
Metrics: https://runbooks.oversight.com/metrics
Docs: https://runbooks.oversight.com/docs
```

### Runbook Categories
```
Infrastructure: Node, Pod, Network issues
Application: Performance, Errors, Deployments
Database: Connections, Performance, Maintenance
Security: Incidents, Compliance, Access
Business: SLA, Customer impact, Revenue
```

### Self-Healing Policies
- OOM: Auto-restart with increased memory
- High Latency: Scale up, clear cache
- Certificate Expiry: Auto-renewal
- Disk Full: Clean logs, archives
- Connection Pool: Reset connections

### Approval Requirements
- Production changes: Always
- Data deletion: Always
- Node operations: If > 1 node
- Scaling: If > 50% change
- Security: Always for isolation

### Testing Standards
- Test location: `/tests/sre/runbooks/`
- Test each runbook execution
- Verify rollback mechanisms
- Test approval workflows
- Monitor self-healing effectiveness

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_