# Story 5.5: Configure DDoS Protection

**Epic:** 5 - CBE Distribution  
**Story Number:** 5.5  
**Title:** Implement Multi-Layer DDoS Mitigation  
**Status:** READY  
**Points:** 5  
**Component:** 535 (DDoS Protection)  

---

## Story

**As a** Security Engineer,  
**I want** comprehensive DDoS protection at all layers,  
**so that** the service remains available during volumetric, protocol, and application-layer attacks.

---

## Acceptance Criteria

1. Layer 3/4 DDoS protection with automatic mitigation
2. Layer 7 DDoS protection with behavioral analysis
3. Scrubbing centers in multiple regions
4. Attack detection < 10 seconds
5. Mitigation activation < 30 seconds
6. False positive rate < 0.1%
7. Real-time attack dashboards
8. Post-attack forensics and reporting

---

## Tasks / Subtasks

### Task 1: Write DDoS Protection Tests (TDD) (AC: 4, 5, 6)
- [ ] Create `security/ddos_test.go`
  - [ ] Test detection speed
  - [ ] Test mitigation activation
  - [ ] Test false positive rate
  - [ ] Test traffic scrubbing
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy Network Layer Protection (AC: 1, 3)
- [ ] Configure Azure DDoS Protection
  ```hcl
  resource "azurerm_network_ddos_protection_plan" "main" {
    name                = "ddos-protection-oversight"
    location            = var.location
    resource_group_name = azurerm_resource_group.network.name
    
    tags = {
      environment = "production"
      component   = "ddos-protection"
    }
  }
  
  resource "azurerm_virtual_network" "protected" {
    name                = "vnet-oversight-protected"
    location            = var.location
    resource_group_name = azurerm_resource_group.network.name
    address_space       = ["10.0.0.0/16"]
    
    ddos_protection_plan {
      id     = azurerm_network_ddos_protection_plan.main.id
      enable = true
    }
  }
  
  resource "azurerm_monitor_diagnostic_setting" "ddos" {
    name               = "ddos-diagnostics"
    target_resource_id = azurerm_network_ddos_protection_plan.main.id
    
    log_analytics_workspace_id = azurerm_log_analytics_workspace.security.id
    
    metric {
      category = "AllMetrics"
      
      retention_policy {
        enabled = true
        days    = 90
      }
    }
    
    enabled_log {
      category = "DDoSProtectionNotifications"
      
      retention_policy {
        enabled = true
        days    = 90
      }
    }
    
    enabled_log {
      category = "DDoSMitigationFlowLogs"
      
      retention_policy {
        enabled = true
        days    = 30
      }
    }
    
    enabled_log {
      category = "DDoSMitigationReports"
      
      retention_policy {
        enabled = true
        days    = 90
      }
    }
  }
  ```
- [ ] Setup scrubbing centers
  ```javascript
  // services/scrubbing-center.js
  class ScrubbingCenter {
    constructor() {
      this.centers = {
        'us-east': {
          location: 'Virginia',
          capacity: '100 Gbps',
          ip_range: '10.1.0.0/16'
        },
        'eu-west': {
          location: 'Amsterdam',
          capacity: '100 Gbps',
          ip_range: '10.2.0.0/16'
        },
        'asia-pac': {
          location: 'Singapore',
          capacity: '50 Gbps',
          ip_range: '10.3.0.0/16'
        }
      };
      
      this.mitigationPolicies = {
        volumetric: new VolumetricMitigation(),
        protocol: new ProtocolMitigation(),
        application: new ApplicationMitigation()
      };
    }
    
    async detectAttack(traffic) {
      const detectionStart = Date.now();
      
      // Multi-layer detection
      const detections = await Promise.all([
        this.detectVolumetric(traffic),
        this.detectProtocolAnomaly(traffic),
        this.detectApplicationLayer(traffic),
        this.detectAmplification(traffic)
      ]);
      
      const detected = detections.filter(d => d.detected);
      
      if (detected.length > 0) {
        const detection = {
          timestamp: new Date(),
          detectionTime: Date.now() - detectionStart,
          attacks: detected,
          confidence: this.calculateConfidence(detected),
          severity: this.calculateSeverity(detected)
        };
        
        if (detection.confidence > 0.8) {
          await this.inititateMitigation(detection);
        }
        
        return detection;
      }
      
      return null;
    }
    
    async detectVolumetric(traffic) {
      const baseline = await this.getBaseline();
      const current = {
        pps: traffic.packetsPerSecond,
        bps: traffic.bitsPerSecond,
        connections: traffic.connectionsPerSecond
      };
      
      // Check for traffic spike
      const ppsRatio = current.pps / baseline.pps;
      const bpsRatio = current.bps / baseline.bps;
      const connRatio = current.connections / baseline.connections;
      
      if (ppsRatio > 10 || bpsRatio > 10 || connRatio > 10) {
        return {
          detected: true,
          type: 'volumetric',
          metrics: {
            ppsRatio,
            bpsRatio,
            connRatio
          },
          confidence: Math.min(1, Math.max(ppsRatio, bpsRatio, connRatio) / 10)
        };
      }
      
      return { detected: false };
    }
    
    async detectProtocolAnomaly(traffic) {
      const anomalies = [];
      
      // SYN flood detection
      if (traffic.synPackets / traffic.ackPackets > 3) {
        anomalies.push({
          type: 'syn_flood',
          ratio: traffic.synPackets / traffic.ackPackets
        });
      }
      
      // UDP flood detection
      if (traffic.udpPackets > traffic.totalPackets * 0.8) {
        anomalies.push({
          type: 'udp_flood',
          percentage: (traffic.udpPackets / traffic.totalPackets) * 100
        });
      }
      
      // ICMP flood detection
      if (traffic.icmpPackets > traffic.totalPackets * 0.3) {
        anomalies.push({
          type: 'icmp_flood',
          percentage: (traffic.icmpPackets / traffic.totalPackets) * 100
        });
      }
      
      // Fragmented packets
      if (traffic.fragmentedPackets > traffic.totalPackets * 0.1) {
        anomalies.push({
          type: 'fragmentation_attack',
          percentage: (traffic.fragmentedPackets / traffic.totalPackets) * 100
        });
      }
      
      if (anomalies.length > 0) {
        return {
          detected: true,
          type: 'protocol',
          anomalies,
          confidence: Math.min(1, anomalies.length / 2)
        };
      }
      
      return { detected: false };
    }
    
    async inititateMitigation(detection) {
      console.log(`Initiating DDoS mitigation: ${JSON.stringify(detection)}`);
      
      const mitigation = {
        id: this.generateId(),
        detection: detection,
        startTime: Date.now(),
        status: 'mitigating'
      };
      
      // Select scrubbing center
      const center = this.selectScrubbingCenter(detection);
      
      // Redirect traffic to scrubbing center
      await this.redirectTraffic(center);
      
      // Apply mitigation policies
      for (const attack of detection.attacks) {
        const policy = this.mitigationPolicies[attack.type];
        await policy.apply(attack, center);
      }
      
      mitigation.center = center;
      mitigation.activationTime = Date.now() - mitigation.startTime;
      
      // Monitor mitigation effectiveness
      this.monitorMitigation(mitigation);
      
      return mitigation;
    }
    
    async redirectTraffic(center) {
      // BGP announcement to redirect traffic
      await this.bgpController.announce({
        prefix: this.protectedPrefix,
        nextHop: center.ip_range,
        communities: ['64512:666'], // DDoS mitigation community
        preference: 200
      });
      
      // Update DNS to point to scrubbing center
      await this.dnsController.update({
        record: 'oversight.com',
        type: 'A',
        value: center.anycast_ip,
        ttl: 60
      });
    }
  }
  ```
- [ ] Configure BGP FlowSpec
- [ ] Setup anycast routing

### Task 3: Implement Application Layer Protection (AC: 2, 6)
- [ ] Deploy L7 DDoS protection
  ```javascript
  // services/l7-ddos-protection.js
  class Layer7DDoSProtection {
    constructor() {
      this.profiles = new Map();
      this.challenges = {
        javascript: new JavaScriptChallenge(),
        captcha: new CaptchaChallenge(),
        rateLimit: new RateLimitChallenge(),
        deviceFingerprint: new DeviceFingerprintChallenge()
      };
    }
    
    async analyzeRequest(request) {
      const profile = await this.getOrCreateProfile(request);
      
      // Behavioral analysis
      const behaviorScore = await this.analyzeBehavior(request, profile);
      
      // Pattern matching
      const patterns = await this.detectPatterns(request);
      
      // Reputation check
      const reputation = await this.checkReputation(request);
      
      // Calculate threat score
      const threatScore = this.calculateThreatScore({
        behavior: behaviorScore,
        patterns,
        reputation
      });
      
      profile.threatScore = threatScore;
      profile.lastSeen = Date.now();
      
      return {
        profile,
        threatScore,
        action: this.determineAction(threatScore)
      };
    }
    
    async analyzeBehavior(request, profile) {
      const metrics = {
        requestRate: this.calculateRequestRate(profile),
        entropy: this.calculateEntropy(request),
        mouseMovement: request.mouseData ? this.analyzeMouseMovement(request.mouseData) : 0,
        keystrokes: request.keystrokeData ? this.analyzeKeystrokes(request.keystrokeData) : 0,
        consistency: this.checkConsistency(request, profile)
      };
      
      // Machine learning model for behavior scoring
      const score = await this.mlModel.predict(metrics);
      
      // Update profile
      profile.behaviorHistory.push({
        timestamp: Date.now(),
        metrics,
        score
      });
      
      // Keep only recent history
      if (profile.behaviorHistory.length > 100) {
        profile.behaviorHistory.shift();
      }
      
      return score;
    }
    
    async detectPatterns(request) {
      const patterns = [];
      
      // Check for known attack patterns
      const attackPatterns = [
        {
          name: 'slowloris',
          check: () => request.headers['content-length'] > 100000 && 
                       request.readSpeed < 100 // bytes/second
        },
        {
          name: 'http_flood',
          check: () => request.userAgent === '' || 
                       request.userAgent.match(/^(bot|crawler|scanner)/)
        },
        {
          name: 'cache_busting',
          check: () => request.url.includes('?') && 
                       this.isRandomParameter(request.query)
        },
        {
          name: 'xml_bomb',
          check: () => request.contentType === 'application/xml' && 
                       request.body.length > 1000000
        },
        {
          name: 'application_dos',
          check: () => this.isResourceIntensive(request.url)
        }
      ];
      
      for (const pattern of attackPatterns) {
        if (pattern.check()) {
          patterns.push(pattern.name);
        }
      }
      
      return patterns;
    }
    
    async checkReputation(request) {
      const checks = await Promise.all([
        this.checkIPReputation(request.ip),
        this.checkASNReputation(request.asn),
        this.checkGeoReputation(request.country),
        this.checkUserAgentReputation(request.userAgent)
      ]);
      
      return {
        ip: checks[0],
        asn: checks[1],
        geo: checks[2],
        userAgent: checks[3],
        overall: Math.min(...checks)
      };
    }
    
    determineAction(threatScore) {
      if (threatScore < 0.3) {
        return { action: 'allow', reason: 'low_threat' };
      }
      
      if (threatScore < 0.5) {
        return { 
          action: 'challenge',
          type: 'javascript',
          reason: 'moderate_threat'
        };
      }
      
      if (threatScore < 0.7) {
        return {
          action: 'challenge',
          type: 'captcha',
          reason: 'high_threat'
        };
      }
      
      if (threatScore < 0.9) {
        return {
          action: 'rate_limit',
          limit: 1,
          duration: 3600,
          reason: 'very_high_threat'
        };
      }
      
      return {
        action: 'block',
        duration: 86400,
        reason: 'extreme_threat'
      };
    }
    
    async applyChallenge(request, challenge) {
      switch (challenge.type) {
        case 'javascript':
          return await this.challenges.javascript.generate(request);
        
        case 'captcha':
          return await this.challenges.captcha.generate(request);
        
        case 'rate_limit':
          return await this.challenges.rateLimit.apply(request, challenge.limit);
        
        case 'device_fingerprint':
          return await this.challenges.deviceFingerprint.verify(request);
        
        default:
          return { success: false };
      }
    }
    
    async adaptiveProtection(metrics) {
      // Dynamically adjust protection based on attack
      const currentLoad = metrics.requestsPerSecond;
      const normalLoad = await this.getNormalLoad();
      const loadRatio = currentLoad / normalLoad;
      
      if (loadRatio > 5) {
        // Under attack - increase protection
        await this.increasProtection({
          javascriptChallenge: loadRatio > 10,
          captchaChallenge: loadRatio > 20,
          strictRateLimit: true,
          blockSuspiciousASNs: true
        });
      } else if (loadRatio < 1.5) {
        // Normal traffic - reduce friction
        await this.reduceProtection({
          javascriptChallenge: false,
          captchaChallenge: false,
          strictRateLimit: false,
          blockSuspiciousASNs: false
        });
      }
    }
  }
  ```
- [ ] Configure behavioral analysis
- [ ] Setup challenge systems
- [ ] Implement ML-based detection

### Task 4: Setup Attack Detection (AC: 4)
- [ ] Create detection engine
  ```javascript
  // services/attack-detection.js
  class AttackDetectionEngine {
    constructor() {
      this.detectors = {
        statistical: new StatisticalDetector(),
        behavioral: new BehavioralDetector(),
        signature: new SignatureDetector(),
        anomaly: new AnomalyDetector(),
        ml: new MLDetector()
      };
      
      this.detectionWindow = 10000; // 10 seconds
      this.alerts = new Map();
    }
    
    async detectAttacks() {
      const startTime = Date.now();
      const traffic = await this.collectTrafficData();
      
      // Run all detectors in parallel
      const detections = await Promise.all(
        Object.entries(this.detectors).map(async ([name, detector]) => {
          const result = await detector.analyze(traffic);
          return { name, result };
        })
      );
      
      // Aggregate results
      const attacks = detections
        .filter(d => d.result.detected)
        .map(d => ({
          ...d.result,
          detector: d.name,
          confidence: d.result.confidence
        }));
      
      if (attacks.length > 0) {
        const alert = {
          id: this.generateAlertId(),
          timestamp: new Date(),
          detectionTime: Date.now() - startTime,
          attacks,
          overallConfidence: this.calculateOverallConfidence(attacks),
          severity: this.calculateSeverity(attacks)
        };
        
        this.alerts.set(alert.id, alert);
        
        // Trigger mitigation if confidence is high
        if (alert.overallConfidence > 0.8) {
          await this.triggerMitigation(alert);
        }
        
        return alert;
      }
      
      return null;
    }
    
    async collectTrafficData() {
      const [
        networkMetrics,
        applicationMetrics,
        geoDistribution,
        protocolDistribution,
        payloadAnalysis
      ] = await Promise.all([
        this.collectNetworkMetrics(),
        this.collectApplicationMetrics(),
        this.analyzeGeoDistribution(),
        this.analyzeProtocolDistribution(),
        this.analyzePayloads()
      ]);
      
      return {
        timestamp: Date.now(),
        network: networkMetrics,
        application: applicationMetrics,
        geo: geoDistribution,
        protocols: protocolDistribution,
        payloads: payloadAnalysis
      };
    }
    
    async collectNetworkMetrics() {
      const metrics = await this.networkMonitor.getMetrics();
      
      return {
        packetsPerSecond: metrics.pps,
        bitsPerSecond: metrics.bps,
        connectionsPerSecond: metrics.cps,
        uniqueSourceIPs: metrics.uniqueSources,
        topSources: metrics.topSources,
        packetSizes: metrics.packetSizeDistribution,
        ttlDistribution: metrics.ttlDistribution,
        fragmentation: metrics.fragmentationRate
      };
    }
    
    calculateOverallConfidence(attacks) {
      // Weight by detector reliability
      const weights = {
        ml: 0.35,
        behavioral: 0.25,
        statistical: 0.20,
        anomaly: 0.15,
        signature: 0.05
      };
      
      let weightedSum = 0;
      let totalWeight = 0;
      
      for (const attack of attacks) {
        const weight = weights[attack.detector] || 0.1;
        weightedSum += attack.confidence * weight;
        totalWeight += weight;
      }
      
      return totalWeight > 0 ? weightedSum / totalWeight : 0;
    }
    
    async triggerMitigation(alert) {
      console.log(`Triggering mitigation for alert ${alert.id}`);
      
      // Select mitigation strategy based on attack types
      const strategy = this.selectMitigationStrategy(alert.attacks);
      
      // Activate mitigation
      await this.mitigationController.activate({
        alertId: alert.id,
        strategy,
        severity: alert.severity,
        attacks: alert.attacks
      });
      
      // Log for forensics
      await this.forensicsLogger.log({
        event: 'mitigation_triggered',
        alert,
        strategy,
        timestamp: new Date()
      });
    }
  }
  ```
- [ ] Configure detection thresholds
- [ ] Setup ML models
- [ ] Test detection accuracy

### Task 5: Implement Mitigation Activation (AC: 5)
- [ ] Create mitigation controller
  ```javascript
  // services/mitigation-controller.js
  class MitigationController {
    constructor() {
      this.strategies = {
        blackhole: new BlackholeStrategy(),
        scrubbing: new ScrubbingStrategy(),
        rateLimit: new RateLimitStrategy(),
        geoBlock: new GeoBlockStrategy(),
        challenge: new ChallengeStrategy()
      };
      
      this.activeMitigations = new Map();
      this.activationTarget = 30000; // 30 seconds
    }
    
    async activate(config) {
      const startTime = Date.now();
      
      const mitigation = {
        id: this.generateId(),
        alertId: config.alertId,
        startTime,
        status: 'activating',
        strategies: []
      };
      
      this.activeMitigations.set(mitigation.id, mitigation);
      
      try {
        // Deploy strategies in parallel for speed
        const deployments = config.strategy.map(async strategyName => {
          const strategy = this.strategies[strategyName];
          const deployment = await strategy.deploy(config);
          return { name: strategyName, deployment };
        });
        
        mitigation.strategies = await Promise.all(deployments);
        
        // Verify activation
        await this.verifyActivation(mitigation);
        
        mitigation.activationTime = Date.now() - startTime;
        mitigation.status = 'active';
        
        console.log(`Mitigation ${mitigation.id} activated in ${mitigation.activationTime}ms`);
        
        if (mitigation.activationTime > this.activationTarget) {
          console.warn(`Activation exceeded target: ${mitigation.activationTime}ms > ${this.activationTarget}ms`);
        }
        
        // Start effectiveness monitoring
        this.monitorEffectiveness(mitigation);
        
        return mitigation;
      } catch (error) {
        mitigation.status = 'failed';
        mitigation.error = error.message;
        throw error;
      }
    }
    
    async verifyActivation(mitigation) {
      const verifications = await Promise.all(
        mitigation.strategies.map(async s => {
          const strategy = this.strategies[s.name];
          return await strategy.verify(s.deployment);
        })
      );
      
      const failed = verifications.filter(v => !v.success);
      if (failed.length > 0) {
        throw new Error(`Verification failed for: ${failed.map(f => f.name).join(', ')}`);
      }
    }
    
    async monitorEffectiveness(mitigation) {
      const monitor = setInterval(async () => {
        const metrics = await this.collectMetrics();
        const effectiveness = await this.calculateEffectiveness(mitigation, metrics);
        
        if (effectiveness < 0.5) {
          // Mitigation not effective, escalate
          console.log(`Mitigation ${mitigation.id} ineffective, escalating`);
          await this.escalate(mitigation);
        } else if (effectiveness > 0.9 && Date.now() - mitigation.startTime > 300000) {
          // Attack subsided, consider deactivation
          console.log(`Attack subsiding, preparing to deactivate ${mitigation.id}`);
          await this.prepareDeactivation(mitigation);
        }
        
        // Log metrics
        await this.logMetrics({
          mitigationId: mitigation.id,
          effectiveness,
          metrics,
          timestamp: new Date()
        });
      }, 30000); // Check every 30 seconds
      
      mitigation.monitor = monitor;
    }
    
    async escalate(mitigation) {
      // Try more aggressive strategies
      const escalationStrategies = ['blackhole', 'geoBlock'];
      
      for (const strategy of escalationStrategies) {
        if (!mitigation.strategies.find(s => s.name === strategy)) {
          console.log(`Escalating to ${strategy}`);
          
          const deployment = await this.strategies[strategy].deploy({
            mitigationId: mitigation.id,
            escalation: true
          });
          
          mitigation.strategies.push({
            name: strategy,
            deployment,
            escalatedAt: Date.now()
          });
        }
      }
      
      // Notify SOC
      await this.notifySOC({
        event: 'mitigation_escalation',
        mitigation,
        reason: 'ineffective_mitigation'
      });
    }
  }
  ```
- [ ] Configure auto-scaling
- [ ] Setup strategy selection
- [ ] Test activation speed

### Task 6: Minimize False Positives (AC: 6)
- [ ] Implement whitelist management
  ```javascript
  // services/whitelist-manager.js
  class WhitelistManager {
    constructor() {
      this.whitelists = {
        ip: new Set(),
        asn: new Set(),
        userAgent: new Set(),
        domain: new Set(),
        fingerprint: new Set()
      };
      
      this.dynamicWhitelist = new Map();
      this.reputationThreshold = 0.9;
    }
    
    async evaluateRequest(request) {
      // Check static whitelists
      if (this.isStaticallyWhitelisted(request)) {
        return { whitelisted: true, reason: 'static_whitelist' };
      }
      
      // Check dynamic whitelist
      if (this.isDynamicallyWhitelisted(request)) {
        return { whitelisted: true, reason: 'dynamic_whitelist' };
      }
      
      // Check reputation
      const reputation = await this.checkReputation(request);
      if (reputation.score > this.reputationThreshold) {
        // Add to dynamic whitelist
        this.addToDynamicWhitelist(request, reputation);
        return { whitelisted: true, reason: 'high_reputation' };
      }
      
      // Check behavioral patterns
      const behavioral = await this.checkBehavioral(request);
      if (behavioral.legitimate > 0.95) {
        return { whitelisted: true, reason: 'legitimate_behavior' };
      }
      
      return { whitelisted: false };
    }
    
    isStaticallyWhitelisted(request) {
      return (
        this.whitelists.ip.has(request.ip) ||
        this.whitelists.asn.has(request.asn) ||
        this.whitelists.userAgent.has(request.userAgent) ||
        this.whitelists.domain.has(request.domain)
      );
    }
    
    isDynamicallyWhitelisted(request) {
      const entry = this.dynamicWhitelist.get(request.fingerprint);
      
      if (!entry) return false;
      
      // Check if whitelist entry is still valid
      const age = Date.now() - entry.timestamp;
      const maxAge = entry.reputation * 86400000; // Higher reputation = longer whitelist
      
      if (age > maxAge) {
        this.dynamicWhitelist.delete(request.fingerprint);
        return false;
      }
      
      // Update last seen
      entry.lastSeen = Date.now();
      entry.requests++;
      
      return true;
    }
    
    async checkBehavioral(request) {
      const patterns = {
        // Human-like interaction patterns
        hasMouseMovement: request.mouseData?.length > 0,
        hasKeystrokes: request.keystrokeData?.length > 0,
        reasonableScrolling: this.analyzeScrollPattern(request.scrollData),
        
        // Session consistency
        consistentHeaders: this.checkHeaderConsistency(request),
        validReferer: this.validateReferer(request),
        
        // Timing patterns
        humanTiming: this.checkTimingPatterns(request),
        
        // Content interaction
        formInteraction: this.checkFormInteraction(request),
        
        // Technical indicators
        javascriptEnabled: request.headers['x-js-enabled'] === 'true',
        cookiesEnabled: request.headers.cookie !== undefined
      };
      
      const score = Object.values(patterns).filter(v => v).length / Object.keys(patterns).length;
      
      return {
        legitimate: score,
        patterns
      };
    }
    
    async reduceFalsePositives() {
      // Machine learning model to identify false positives
      const recentBlocks = await this.getRecentBlocks();
      
      const analysis = await this.mlModel.analyzeFalsePositives(recentBlocks);
      
      for (const fp of analysis.likelyFalsePositives) {
        // Add to whitelist
        if (fp.confidence > 0.9) {
          this.addToWhitelist(fp.identifier, fp.type);
          
          // Log for review
          await this.logFalsePositive({
            identifier: fp.identifier,
            type: fp.type,
            confidence: fp.confidence,
            addedToWhitelist: true
          });
        }
      }
      
      return analysis;
    }
  }
  ```
- [ ] Configure ML tuning
- [ ] Setup feedback loop
- [ ] Test false positive rate

### Task 7: Create Attack Dashboard (AC: 7)
- [ ] Build real-time dashboard
  ```javascript
  // services/ddos-dashboard.js
  class DDoSDashboard {
    constructor() {
      this.metrics = {
        realtime: new RealtimeMetrics(),
        historical: new HistoricalMetrics(),
        geographic: new GeographicMetrics(),
        attacks: new AttackMetrics()
      };
    }
    
    async generateDashboard() {
      const [
        currentStatus,
        activeAttacks,
        recentAttacks,
        metrics,
        geographic,
        effectiveness
      ] = await Promise.all([
        this.getCurrentStatus(),
        this.getActiveAttacks(),
        this.getRecentAttacks(24),
        this.getMetrics(),
        this.getGeographicData(),
        this.getMitigationEffectiveness()
      ]);
      
      return {
        status: currentStatus,
        attacks: {
          active: activeAttacks,
          recent: recentAttacks
        },
        metrics,
        geographic,
        effectiveness,
        generated: new Date()
      };
    }
    
    async getCurrentStatus() {
      const traffic = await this.metrics.realtime.getTraffic();
      const baseline = await this.metrics.historical.getBaseline();
      
      const status = {
        level: 'normal',
        trafficRatio: traffic.current / baseline.normal,
        activeMetigations: await this.getActiveMitigations(),
        metrics: {
          pps: traffic.pps,
          bps: traffic.bps,
          connections: traffic.connections,
          uniqueIPs: traffic.uniqueIPs
        }
      };
      
      if (status.trafficRatio > 10) {
        status.level = 'critical';
      } else if (status.trafficRatio > 5) {
        status.level = 'high';
      } else if (status.trafficRatio > 2) {
        status.level = 'elevated';
      }
      
      return status;
    }
    
    async getActiveAttacks() {
      const attacks = await this.metrics.attacks.getActive();
      
      return attacks.map(attack => ({
        id: attack.id,
        type: attack.type,
        startTime: attack.startTime,
        duration: Date.now() - attack.startTime,
        peakTraffic: attack.peakTraffic,
        sources: attack.topSources,
        targetedServices: attack.targets,
        mitigationStatus: attack.mitigation?.status || 'detecting',
        effectiveness: attack.mitigation?.effectiveness || 0
      }));
    }
    
    async getGeographicData() {
      const geoData = await this.metrics.geographic.getDistribution();
      
      return {
        attackSources: geoData.sources.map(s => ({
          country: s.country,
          percentage: s.percentage,
          ips: s.uniqueIPs,
          asns: s.topASNs,
          reputation: s.averageReputation
        })),
        targetedRegions: geoData.targets,
        heatmap: geoData.heatmap,
        trends: geoData.trends
      };
    }
    
    async generateRealtimeStream() {
      return new ReadableStream({
        start(controller) {
          const interval = setInterval(async () => {
            const update = {
              timestamp: Date.now(),
              traffic: await this.metrics.realtime.getSnapshot(),
              attacks: await this.metrics.attacks.getUpdates(),
              mitigations: await this.getMitigationUpdates()
            };
            
            controller.enqueue(JSON.stringify(update) + '\n');
          }, 1000);
          
          return () => clearInterval(interval);
        }
      });
    }
  }
  ```
- [ ] Configure websocket updates
- [ ] Setup alerting
- [ ] Create visualizations

### Task 8: Implement Forensics (AC: 8)
- [ ] Create forensics collector
  ```javascript
  // services/ddos-forensics.js
  class DDoSForensics {
    constructor() {
      this.storage = new ForensicsStorage();
      this.analyzer = new TrafficAnalyzer();
    }
    
    async captureAttack(attackId) {
      console.log(`Starting forensic capture for attack ${attackId}`);
      
      const capture = {
        id: this.generateCaptureId(),
        attackId,
        startTime: Date.now(),
        data: {
          packets: [],
          flows: [],
          sources: new Set(),
          patterns: []
        }
      };
      
      // Start packet capture
      const pcapStream = await this.startPacketCapture({
        filter: this.getAttackFilter(attackId),
        maxPackets: 1000000,
        maxSize: '1GB'
      });
      
      // Collect attack data
      pcapStream.on('packet', packet => {
        capture.data.packets.push(this.sanitizePacket(packet));
        capture.data.sources.add(packet.source);
      });
      
      // Analyze flows
      const flows = await this.analyzer.extractFlows(pcapStream);
      capture.data.flows = flows;
      
      // Detect patterns
      capture.data.patterns = await this.analyzer.detectPatterns(capture.data);
      
      // Store capture
      await this.storage.store(capture);
      
      return capture;
    }
    
    async generateReport(attackId) {
      const capture = await this.storage.retrieve(attackId);
      const analysis = await this.analyzeCapture(capture);
      
      const report = {
        summary: {
          attackId,
          startTime: capture.startTime,
          duration: capture.duration,
          peakTraffic: analysis.peakTraffic,
          totalPackets: capture.data.packets.length,
          uniqueSources: capture.data.sources.size,
          attackVectors: analysis.vectors
        },
        
        timeline: this.generateTimeline(capture),
        
        sources: {
          topIPs: analysis.topSources.slice(0, 100),
          topASNs: analysis.topASNs,
          geographic: analysis.geoDistribution,
          botnetAnalysis: analysis.botnetIndicators
        },
        
        patterns: {
          detected: capture.data.patterns,
          signatures: analysis.signatures,
          anomalies: analysis.anomalies
        },
        
        mitigation: {
          strategiesUsed: analysis.mitigationStrategies,
          effectiveness: analysis.effectiveness,
          timeline: analysis.mitigationTimeline
        },
        
        recommendations: await this.generateRecommendations(analysis),
        
        technical: {
          pcapFile: capture.pcapUrl,
          flowData: capture.flowDataUrl,
          rawLogs: capture.rawLogsUrl
        }
      };
      
      // Generate PDF report
      const pdf = await this.generatePDF(report);
      
      return {
        report,
        pdf,
        url: await this.storage.getReportUrl(attackId)
      };
    }
    
    async analyzeCapture(capture) {
      return {
        peakTraffic: this.findPeakTraffic(capture.data.packets),
        vectors: this.identifyAttackVectors(capture.data),
        topSources: this.getTopSources(capture.data.sources),
        topASNs: await this.resolveASNs(capture.data.sources),
        geoDistribution: await this.getGeoDistribution(capture.data.sources),
        botnetIndicators: this.detectBotnet(capture.data),
        signatures: this.matchSignatures(capture.data.patterns),
        anomalies: this.detectAnomalies(capture.data),
        mitigationStrategies: await this.getMitigationStrategies(capture.attackId),
        effectiveness: await this.calculateEffectiveness(capture),
        mitigationTimeline: await this.getMitigationTimeline(capture.attackId)
      };
    }
  }
  ```
- [ ] Setup packet capture
- [ ] Configure report generation
- [ ] Create evidence chain

---

## Dev Notes

### DDoS Protection Layers
```
Layer 3/4: Azure DDoS Protection Standard
Layer 7: Azure Front Door + Custom Rules
Edge: CloudFlare or Akamai
Application: Rate limiting + Challenges
```

### Detection Thresholds
```
Traffic Spike: 10x baseline = High confidence
SYN/ACK Ratio: > 3:1 = SYN flood
UDP Traffic: > 80% = UDP flood
New Connections: > 1000/sec = Connection flood
```

### Mitigation Strategies
```
Volumetric: Traffic scrubbing, Blackhole
Protocol: SYN cookies, Rate limiting
Application: JS challenges, CAPTCHA, Fingerprinting
Amplification: Block reflection ports
```

### False Positive Reduction
- Whitelist known good IPs/ASNs
- Behavioral analysis for legitimate users
- ML model training on false positives
- Progressive challenges (JS â†’ CAPTCHA)

### Testing Standards
- Test location: `/tests/security/ddos/`
- Simulate various attack types
- Measure detection time < 10s
- Verify mitigation < 30s
- Check false positive rate < 0.1%

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_