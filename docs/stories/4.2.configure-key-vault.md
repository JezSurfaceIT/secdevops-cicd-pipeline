# Story 4.2: Configure Key Vault Integration

**Epic:** 4 - Production SaaS Deployment  
**Story Number:** 4.2  
**Title:** Implement Azure Key Vault for Secret Management  
**Status:** READY  
**Points:** 5  
**Component:** 714 (Azure Key Vault)  

---

## Story

**As a** Security Engineer,  
**I want** all production secrets managed through Azure Key Vault,  
**so that** sensitive data is centrally managed, rotated, and accessed securely without hardcoding.

---

## Acceptance Criteria

1. Azure Key Vault deployed with Standard SKU
2. All production secrets migrated to Key Vault
3. Secret rotation policies configured
4. Access policies configured for App Service MI
5. Soft delete and purge protection enabled
6. Diagnostic logging to Log Analytics
7. Secret versioning implemented
8. Backup and recovery procedures documented

---

## Tasks / Subtasks

### Task 1: Write Security Tests (TDD) (AC: 1, 4, 5)
- [ ] Create `production/key_vault_test.go`
  - [ ] Test Key Vault exists
  - [ ] Test soft delete enabled
  - [ ] Test access policies configured
  - [ ] Test secrets accessible via MI
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy Key Vault Infrastructure (AC: 1, 5)
- [ ] Create Key Vault resource
  ```hcl
  resource "azurerm_key_vault" "main" {
    name                        = "kv-oversight-prod"
    location                    = var.location
    resource_group_name         = "rg-oversight-prod-saas-eastus"
    tenant_id                   = data.azurerm_client_config.current.tenant_id
    sku_name                   = "standard"
    
    # Security settings
    enabled_for_deployment          = false
    enabled_for_disk_encryption     = false
    enabled_for_template_deployment = false
    enable_rbac_authorization       = false
    purge_protection_enabled        = true
    soft_delete_retention_days      = 90
    
    network_acls {
      default_action = "Deny"
      bypass         = "AzureServices"
      
      ip_rules = [
        "172.178.53.198/32"  # App Gateway public IP
      ]
      
      virtual_network_subnet_ids = [
        azurerm_subnet.saas_app.id,
        azurerm_subnet.saas_keyvault.id
      ]
    }
    
    contact {
      email = "security-team@oversight.com"
      name  = "Security Team"
    }
    
    tags = {
      environment = "production"
      component   = "security"
      compliance  = "required"
    }
  }
  
  # Enable diagnostic logging
  resource "azurerm_monitor_diagnostic_setting" "key_vault" {
    name               = "diag-key-vault"
    target_resource_id = azurerm_key_vault.main.id
    
    log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id
    
    enabled_log {
      category = "AuditEvent"
      retention_policy {
        enabled = true
        days    = 90
      }
    }
    
    enabled_log {
      category = "AzurePolicyEvaluationDetails"
      retention_policy {
        enabled = true
        days    = 30
      }
    }
    
    metric {
      category = "AllMetrics"
      retention_policy {
        enabled = true
        days    = 30
      }
    }
  }
  ```
- [ ] Configure private endpoint
  ```hcl
  resource "azurerm_private_endpoint" "key_vault" {
    name                = "pe-key-vault"
    location            = var.location
    resource_group_name = "rg-oversight-prod-saas-eastus"
    subnet_id           = azurerm_subnet.saas_keyvault.id
    
    private_service_connection {
      name                           = "psc-key-vault"
      private_connection_resource_id = azurerm_key_vault.main.id
      subresource_names             = ["vault"]
      is_manual_connection          = false
    }
    
    private_dns_zone_group {
      name                 = "pdz-group-kv"
      private_dns_zone_ids = [azurerm_private_dns_zone.key_vault.id]
    }
  }
  ```
- [ ] Setup backup vault
- [ ] Configure geo-replication

### Task 3: Migrate Secrets to Key Vault (AC: 2)
- [ ] Create secret migration script
  ```bash
  #!/bin/bash
  # migrate-secrets.sh
  
  VAULT_NAME="kv-oversight-prod"
  
  # Database credentials
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "database-host" \
    --value "${DB_HOST}"
  
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "database-username" \
    --value "${DB_USER}"
  
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "database-password" \
    --value "${DB_PASSWORD}"
  
  # Redis connection
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "redis-connection-string" \
    --value "${REDIS_CONNECTION}"
  
  # Storage account
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "storage-connection-string" \
    --value "${STORAGE_CONNECTION}"
  
  # API keys
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "sendgrid-api-key" \
    --value "${SENDGRID_KEY}"
  
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "stripe-secret-key" \
    --value "${STRIPE_SECRET}"
  
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "jwt-secret" \
    --value "${JWT_SECRET}"
  
  # OAuth credentials
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "google-oauth-client-id" \
    --value "${GOOGLE_CLIENT_ID}"
  
  az keyvault secret set \
    --vault-name $VAULT_NAME \
    --name "google-oauth-client-secret" \
    --value "${GOOGLE_CLIENT_SECRET}"
  
  echo "Secrets migrated to Key Vault"
  ```
- [ ] Create secret structure
  ```javascript
  // config/secrets.js
  const { SecretClient } = require('@azure/keyvault-secrets');
  const { DefaultAzureCredential } = require('@azure/identity');
  
  class SecretManager {
    constructor() {
      const vaultUrl = process.env.KEY_VAULT_URL;
      const credential = new DefaultAzureCredential();
      this.client = new SecretClient(vaultUrl, credential);
      this.cache = new Map();
      this.cacheTimeout = 300000; // 5 minutes
    }
    
    async getSecret(name) {
      // Check cache
      if (this.cache.has(name)) {
        const cached = this.cache.get(name);
        if (Date.now() - cached.timestamp < this.cacheTimeout) {
          return cached.value;
        }
      }
      
      try {
        const secret = await this.client.getSecret(name);
        
        // Cache the secret
        this.cache.set(name, {
          value: secret.value,
          timestamp: Date.now()
        });
        
        return secret.value;
      } catch (error) {
        console.error(`Failed to retrieve secret ${name}:`, error);
        throw error;
      }
    }
    
    async getDatabaseConfig() {
      return {
        host: await this.getSecret('database-host'),
        user: await this.getSecret('database-username'),
        password: await this.getSecret('database-password'),
        database: await this.getSecret('database-name'),
        port: 5432,
        ssl: true
      };
    }
    
    async getRedisConfig() {
      const connectionString = await this.getSecret('redis-connection-string');
      return this.parseRedisConnection(connectionString);
    }
    
    async refreshSecrets() {
      this.cache.clear();
      console.log('Secret cache cleared');
    }
  }
  
  module.exports = new SecretManager();
  ```
- [ ] Remove hardcoded secrets
- [ ] Update deployment configs

### Task 4: Configure Secret Rotation (AC: 3)
- [ ] Setup rotation policies
  ```hcl
  # Database password rotation
  resource "azurerm_key_vault_secret" "db_password" {
    name         = "database-password"
    value        = random_password.db_password.result
    key_vault_id = azurerm_key_vault.main.id
    
    expiration_date = timeadd(timestamp(), "2160h") # 90 days
    
    content_type = "password"
    
    tags = {
      rotation = "enabled"
      frequency = "90days"
      type = "database"
    }
  }
  
  resource "random_password" "db_password" {
    length  = 32
    special = true
    
    keepers = {
      rotation = timestamp()
    }
  }
  ```
- [ ] Create rotation function
  ```javascript
  // functions/rotate-secrets.js
  const { SecretClient } = require('@azure/keyvault-secrets');
  const { DefaultAzureCredential } = require('@azure/identity');
  const crypto = require('crypto');
  
  module.exports = async function (context, myTimer) {
    const vaultUrl = process.env.KEY_VAULT_URL;
    const credential = new DefaultAzureCredential();
    const client = new SecretClient(vaultUrl, credential);
    
    // Get secrets that need rotation
    const secretsToRotate = [];
    for await (const properties of client.listPropertiesOfSecrets()) {
      if (properties.tags && properties.tags.rotation === 'enabled') {
        const expiresIn = new Date(properties.expiresOn) - new Date();
        
        // Rotate if expiring in less than 7 days
        if (expiresIn < 7 * 24 * 60 * 60 * 1000) {
          secretsToRotate.push(properties.name);
        }
      }
    }
    
    // Rotate each secret
    for (const secretName of secretsToRotate) {
      try {
        const newValue = await rotateSecret(secretName);
        
        await client.setSecret(secretName, newValue, {
          expiresOn: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),
          tags: {
            rotation: 'enabled',
            rotatedOn: new Date().toISOString()
          }
        });
        
        context.log(`Rotated secret: ${secretName}`);
        
        // Update dependent services
        await updateDependentServices(secretName, newValue);
        
      } catch (error) {
        context.log.error(`Failed to rotate ${secretName}:`, error);
      }
    }
  };
  
  async function rotateSecret(name) {
    if (name.includes('password')) {
      return generatePassword();
    } else if (name.includes('api-key')) {
      return generateApiKey();
    } else if (name.includes('jwt')) {
      return generateJwtSecret();
    }
    
    return crypto.randomBytes(32).toString('hex');
  }
  
  function generatePassword() {
    const length = 32;
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+';
    let password = '';
    
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    
    return password;
  }
  ```
- [ ] Setup rotation notifications
- [ ] Test rotation process

### Task 5: Configure Access Policies (AC: 4)
- [ ] Define access policies
  ```hcl
  # App Service access
  resource "azurerm_key_vault_access_policy" "app_service" {
    key_vault_id = azurerm_key_vault.main.id
    tenant_id    = data.azurerm_client_config.current.tenant_id
    object_id    = azurerm_linux_web_app.saas.identity[0].principal_id
    
    secret_permissions = [
      "Get",
      "List"
    ]
    
    certificate_permissions = [
      "Get",
      "List"
    ]
  }
  
  # Admin access
  resource "azurerm_key_vault_access_policy" "admins" {
    key_vault_id = azurerm_key_vault.main.id
    tenant_id    = data.azurerm_client_config.current.tenant_id
    object_id    = data.azuread_group.security_admins.object_id
    
    secret_permissions = [
      "Get",
      "List",
      "Set",
      "Delete",
      "Recover",
      "Backup",
      "Restore",
      "Purge"
    ]
    
    key_permissions = [
      "Get",
      "List",
      "Create",
      "Delete",
      "Recover",
      "Backup",
      "Restore",
      "Purge"
    ]
    
    certificate_permissions = [
      "Get",
      "List",
      "Create",
      "Delete",
      "Recover",
      "Backup",
      "Restore",
      "ManageContacts",
      "ManageIssuers",
      "GetIssuers",
      "ListIssuers",
      "SetIssuers",
      "DeleteIssuers"
    ]
  }
  
  # Function app for rotation
  resource "azurerm_key_vault_access_policy" "rotation_function" {
    key_vault_id = azurerm_key_vault.main.id
    tenant_id    = data.azurerm_client_config.current.tenant_id
    object_id    = azurerm_function_app.rotation.identity[0].principal_id
    
    secret_permissions = [
      "Get",
      "List",
      "Set"
    ]
  }
  ```
- [ ] Configure RBAC if needed
- [ ] Setup emergency access
- [ ] Document access matrix

### Task 6: Configure Logging and Monitoring (AC: 6)
- [ ] Setup comprehensive logging
  ```kusto
  // Key Vault access monitoring
  AzureDiagnostics
  | where ResourceType == "VAULTS"
  | where Category == "AuditEvent"
  | project TimeGenerated, OperationName, CallerIPAddress, ResultType, identity_claim_upn_s
  | where ResultType != "Success"
  | summarize FailedAttempts = count() by CallerIPAddress, identity_claim_upn_s
  | where FailedAttempts > 5
  ```
- [ ] Create alert rules
  ```hcl
  resource "azurerm_monitor_metric_alert" "key_vault_availability" {
    name                = "alert-kv-availability"
    resource_group_name = "rg-oversight-prod-saas-eastus"
    scopes              = [azurerm_key_vault.main.id]
    
    criteria {
      metric_namespace = "Microsoft.KeyVault/vaults"
      metric_name      = "Availability"
      aggregation      = "Average"
      operator         = "LessThan"
      threshold        = 99
    }
    
    action {
      action_group_id = azurerm_monitor_action_group.security.id
    }
  }
  
  resource "azurerm_monitor_activity_log_alert" "key_vault_delete" {
    name                = "alert-kv-delete-operation"
    resource_group_name = "rg-oversight-prod-saas-eastus"
    scopes              = [azurerm_key_vault.main.id]
    
    criteria {
      operation_name = "Microsoft.KeyVault/vaults/delete"
      category       = "Administrative"
    }
    
    action {
      action_group_id = azurerm_monitor_action_group.critical.id
    }
  }
  ```
- [ ] Setup audit reports
- [ ] Configure compliance tracking

### Task 7: Implement Secret Versioning (AC: 7)
- [ ] Create versioning strategy
  ```javascript
  // config/secret-versioning.js
  class SecretVersionManager {
    constructor(secretClient) {
      this.client = secretClient;
    }
    
    async getLatestVersion(secretName) {
      const secret = await this.client.getSecret(secretName);
      return {
        name: secret.name,
        value: secret.value,
        version: secret.properties.version,
        createdOn: secret.properties.createdOn,
        expiresOn: secret.properties.expiresOn
      };
    }
    
    async getSpecificVersion(secretName, version) {
      const secret = await this.client.getSecret(secretName, { version });
      return secret.value;
    }
    
    async listVersions(secretName) {
      const versions = [];
      for await (const properties of this.client.listPropertiesOfSecretVersions(secretName)) {
        versions.push({
          version: properties.version,
          enabled: properties.enabled,
          createdOn: properties.createdOn,
          expiresOn: properties.expiresOn
        });
      }
      return versions;
    }
    
    async rollback(secretName, targetVersion) {
      // Get the target version value
      const oldValue = await this.getSpecificVersion(secretName, targetVersion);
      
      // Set as new secret (creates new version)
      await this.client.setSecret(secretName, oldValue, {
        tags: {
          rollback: 'true',
          rollbackFrom: await this.getLatestVersion(secretName).version,
          rollbackTo: targetVersion
        }
      });
    }
  }
  ```
- [ ] Track version history
- [ ] Implement rollback capability
- [ ] Document version lifecycle

### Task 8: Create Backup and Recovery (AC: 8)
- [ ] Implement backup procedures
  ```bash
  #!/bin/bash
  # backup-keyvault.sh
  
  VAULT_NAME="kv-oversight-prod"
  BACKUP_CONTAINER="keyvault-backups"
  DATE=$(date +%Y%m%d-%H%M%S)
  
  # Backup all secrets
  for SECRET in $(az keyvault secret list --vault-name $VAULT_NAME --query "[].name" -o tsv); do
    echo "Backing up secret: $SECRET"
    
    az keyvault secret backup \
      --vault-name $VAULT_NAME \
      --name $SECRET \
      --file "${SECRET}-${DATE}.backup"
    
    # Upload to storage
    az storage blob upload \
      --container-name $BACKUP_CONTAINER \
      --file "${SECRET}-${DATE}.backup" \
      --name "secrets/${DATE}/${SECRET}.backup"
    
    rm "${SECRET}-${DATE}.backup"
  done
  
  # Backup access policies
  az keyvault show \
    --name $VAULT_NAME \
    --query "properties.accessPolicies" \
    > "access-policies-${DATE}.json"
  
  az storage blob upload \
    --container-name $BACKUP_CONTAINER \
    --file "access-policies-${DATE}.json" \
    --name "policies/${DATE}/access-policies.json"
  ```
- [ ] Test recovery process
- [ ] Document DR procedures
- [ ] Setup automated backups

---

## Dev Notes

### Key Vault URLs
```
Vault URL: https://kv-oversight-prod.vault.azure.net
Private URL: https://kv-oversight-prod.privatelink.vaultcore.azure.net
Backup Storage: https://stoversightprod.blob.core.windows.net/keyvault-backups
```

### Secret Naming Convention
```
Format: {service}-{environment}-{type}
Examples:
- database-prod-password
- redis-prod-connection-string
- sendgrid-prod-api-key
- jwt-prod-secret
```

### Testing Standards
- Test location: `/tests/security/keyvault/`
- Test secret retrieval via MI
- Test rotation triggers
- Verify access policies
- Monitor performance impact

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_