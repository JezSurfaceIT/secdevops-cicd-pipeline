# Story 3.4: Enable Browser-Based Testing

**Epic:** 3 - Test Environment & Automation  
**Story Number:** 3.4  
**Title:** Setup VNC/NoVNC for Manual Testing  
**Status:** READY  
**Points:** 3  
**Component:** 520 (Browser Access)  

---

## Story

**As a** Manual Tester,  
**I want** browser-based access to the test environment,  
**so that** I can perform exploratory testing and debug issues visually.

---

## Acceptance Criteria

1. VNC server running in test environment
2. NoVNC web interface accessible through secure connection
3. Multiple browser sessions supported simultaneously
4. Session recording capability for test evidence
5. Clipboard sharing between local and remote
6. Access controlled through Azure AD authentication
7. Sessions automatically terminate after idle timeout
8. Integration with test management tools

---

## Tasks / Subtasks

### Task 1: Write Access Tests (TDD) (AC: 1, 2, 6)
- [ ] Create `browser-access/vnc_test.go`
  - [ ] Test VNC server is running
  - [ ] Test NoVNC web interface accessible
  - [ ] Test authentication required
  - [ ] Test session creation
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy VNC Infrastructure (AC: 1)
- [ ] Add VNC container to test environment
  ```hcl
  resource "azurerm_container_instance" "vnc_server" {
    name                = "aci-vnc-server"
    location            = var.location
    resource_group_name = "rg-oversight-test-acs-eastus"
    ip_address_type     = "Private"
    subnet_id          = var.subnet_id
    os_type            = "Linux"
    
    container {
      name   = "vnc-server"
      image  = "dorowu/ubuntu-desktop-lxde-vnc:focal"
      cpu    = "2"
      memory = "4"
      
      ports {
        port     = 5900
        protocol = "TCP"
      }
      
      ports {
        port     = 6080
        protocol = "TCP"
      }
      
      environment_variables = {
        VNC_PASSWORD = var.vnc_password
        RESOLUTION   = "1920x1080"
        DEPTH        = "24"
      }
      
      volume {
        name       = "shared-data"
        mount_path = "/data"
        share_name = var.file_share_name
        storage_account_name = var.storage_account_name
        storage_account_key  = var.storage_account_key
      }
    }
  }
  ```
- [ ] Configure VNC settings
- [ ] Setup display resolution options
- [ ] Install required browsers

### Task 3: Configure NoVNC Web Interface (AC: 2, 5)
- [ ] Deploy NoVNC container
  ```dockerfile
  # Dockerfile.novnc
  FROM node:18-alpine
  
  RUN apk add --no-cache git python3 make g++
  
  # Clone NoVNC
  RUN git clone https://github.com/novnc/noVNC.git /novnc
  
  # Clone websockify
  RUN git clone https://github.com/novnc/websockify /novnc/utils/websockify
  
  WORKDIR /novnc
  
  # Custom configuration
  COPY novnc-config.js /novnc/app/config.js
  COPY custom-ui.html /novnc/vnc.html
  
  EXPOSE 6080
  
  CMD ["./utils/launch.sh", "--vnc", "vnc-server:5900", "--listen", "6080"]
  ```
- [ ] Configure WebSocket proxy
  ```javascript
  // novnc-config.js
  export default {
    autoconnect: false,
    password: null,
    encrypt: true,
    host: window.location.hostname,
    port: 6080,
    path: 'websockify',
    logging: 'info',
    
    // Custom settings
    shared: true,
    view_only: false,
    show_dot_cursor: true,
    
    // Clipboard
    clipboard: {
      enabled: true,
      pasteButton: true,
      copyButton: true
    },
    
    // Recording
    recording: {
      enabled: true,
      format: 'webm',
      autoSave: true
    }
  };
  ```
- [ ] Setup SSL/TLS encryption
- [ ] Configure clipboard sharing

### Task 4: Implement Authentication (AC: 6)
- [ ] Integrate Azure AD authentication
  ```javascript
  // auth-middleware.js
  const { BearerStrategy } = require('passport-azure-ad');
  
  const config = {
    identityMetadata: `https://login.microsoftonline.com/${TENANT_ID}/v2.0/.well-known/openid-configuration`,
    clientID: CLIENT_ID,
    validateIssuer: true,
    issuer: `https://login.microsoftonline.com/${TENANT_ID}/v2.0`,
    passReqToCallback: false,
    allowMultiAudiencesInToken: false,
    audience: CLIENT_ID,
    loggingLevel: 'info'
  };
  
  passport.use(new BearerStrategy(config, (token, done) => {
    // Validate user has test environment access
    if (token.groups && token.groups.includes('test-environment-users')) {
      return done(null, token);
    }
    return done(null, false);
  }));
  
  app.use('/vnc', passport.authenticate('oauth-bearer', { session: false }));
  ```
- [ ] Setup session management
- [ ] Configure role-based access
- [ ] Implement audit logging

### Task 5: Setup Multi-Session Support (AC: 3)
- [ ] Configure session manager
  ```javascript
  // session-manager.js
  class VNCSessionManager {
    constructor() {
      this.sessions = new Map();
      this.maxSessions = 10;
    }
    
    async createSession(userId, options = {}) {
      if (this.sessions.size >= this.maxSessions) {
        throw new Error('Maximum sessions reached');
      }
      
      const sessionId = uuidv4();
      const vncPort = await this.allocatePort();
      
      const session = {
        id: sessionId,
        userId,
        vncPort,
        wsPort: vncPort + 100,
        createdAt: new Date(),
        lastActivity: new Date(),
        resolution: options.resolution || '1920x1080',
        recording: options.recording || false
      };
      
      // Start VNC server for this session
      await this.startVNCServer(session);
      
      this.sessions.set(sessionId, session);
      return session;
    }
    
    async startVNCServer(session) {
      const container = await docker.createContainer({
        Image: 'vnc-server:latest',
        Env: [
          `DISPLAY=:${session.vncPort - 5900}`,
          `VNC_PORT=${session.vncPort}`,
          `RESOLUTION=${session.resolution}`
        ],
        HostConfig: {
          PortBindings: {
            '5900/tcp': [{ HostPort: session.vncPort.toString() }]
          }
        }
      });
      
      await container.start();
      session.containerId = container.id;
    }
    
    async terminateSession(sessionId) {
      const session = this.sessions.get(sessionId);
      if (!session) return;
      
      // Stop container
      const container = docker.getContainer(session.containerId);
      await container.stop();
      await container.remove();
      
      // Save recording if enabled
      if (session.recording) {
        await this.saveRecording(session);
      }
      
      this.sessions.delete(sessionId);
    }
  }
  ```
- [ ] Implement load balancing
- [ ] Setup resource limits
- [ ] Configure session persistence

### Task 6: Implement Session Recording (AC: 4)
- [ ] Setup recording infrastructure
  ```javascript
  // recording.js
  const { spawn } = require('child_process');
  
  class SessionRecorder {
    startRecording(session) {
      const outputFile = `/recordings/${session.id}-${Date.now()}.webm`;
      
      const ffmpeg = spawn('ffmpeg', [
        '-f', 'x11grab',
        '-s', session.resolution,
        '-i', `:${session.vncPort - 5900}`,
        '-c:v', 'libvpx',
        '-quality', 'realtime',
        '-cpu-used', '0',
        '-b:v', '2000k',
        '-qmin', '10',
        '-qmax', '42',
        '-maxrate', '2500k',
        '-bufsize', '5000k',
        '-c:a', 'libvorbis',
        '-b:a', '128k',
        '-f', 'webm',
        outputFile
      ]);
      
      session.recordingProcess = ffmpeg;
      session.recordingFile = outputFile;
      
      ffmpeg.on('exit', (code) => {
        console.log(`Recording stopped with code ${code}`);
        this.uploadRecording(session);
      });
    }
    
    stopRecording(session) {
      if (session.recordingProcess) {
        session.recordingProcess.kill('SIGTERM');
      }
    }
    
    async uploadRecording(session) {
      const blobClient = containerClient.getBlockBlobClient(
        `recordings/${session.userId}/${path.basename(session.recordingFile)}`
      );
      
      await blobClient.uploadFile(session.recordingFile);
      
      // Update test management system
      await this.updateTestManagement(session);
    }
  }
  ```
- [ ] Configure storage for recordings
- [ ] Implement playback interface
- [ ] Setup retention policies

### Task 7: Configure Idle Timeout (AC: 7)
- [ ] Implement activity monitoring
  ```javascript
  // idle-monitor.js
  class IdleMonitor {
    constructor(timeout = 30 * 60 * 1000) { // 30 minutes
      this.timeout = timeout;
      this.timers = new Map();
    }
    
    startMonitoring(session) {
      this.resetTimer(session.id);
      
      // Monitor WebSocket activity
      session.ws.on('message', () => {
        this.resetTimer(session.id);
      });
    }
    
    resetTimer(sessionId) {
      if (this.timers.has(sessionId)) {
        clearTimeout(this.timers.get(sessionId));
      }
      
      const timer = setTimeout(() => {
        this.handleIdleTimeout(sessionId);
      }, this.timeout);
      
      this.timers.set(sessionId, timer);
    }
    
    async handleIdleTimeout(sessionId) {
      console.log(`Session ${sessionId} idle timeout`);
      
      // Notify user
      await this.notifyUser(sessionId, 'Session will terminate in 2 minutes due to inactivity');
      
      // Grace period
      setTimeout(async () => {
        if (this.timers.has(sessionId)) {
          await sessionManager.terminateSession(sessionId);
        }
      }, 2 * 60 * 1000);
    }
  }
  ```
- [ ] Configure warning notifications
- [ ] Setup grace period
- [ ] Log timeout events

### Task 8: Integrate with Test Management (AC: 8)
- [ ] Connect to Azure DevOps Test Plans
  ```javascript
  // test-integration.js
  class TestManagementIntegration {
    async linkSession(session, testCaseId) {
      const testRun = await this.azureDevOps.createTestRun({
        name: `Manual Test - ${session.id}`,
        testCase: testCaseId,
        tester: session.userId,
        startTime: session.createdAt
      });
      
      session.testRunId = testRun.id;
    }
    
    async attachRecording(session) {
      if (!session.recordingFile || !session.testRunId) return;
      
      await this.azureDevOps.attachToTestRun(
        session.testRunId,
        session.recordingFile,
        'Session Recording'
      );
    }
    
    async captureScreenshot(session, description) {
      const screenshot = await this.takeVNCScreenshot(session);
      
      await this.azureDevOps.attachToTestRun(
        session.testRunId,
        screenshot,
        description
      );
      
      return screenshot;
    }
  }
  ```
- [ ] Setup test case linking
- [ ] Configure evidence collection
- [ ] Implement defect creation

---

## Dev Notes

### VNC Access URLs
```
Direct VNC: vnc://10.40.1.20:5900
NoVNC Web: https://test.oversight.local/vnc/
API: https://test.oversight.local/api/vnc/sessions
```

### Browser Installation Script
```bash
#!/bin/bash
# install-browsers.sh

# Chrome
wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
echo "deb http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list
apt-get update && apt-get install -y google-chrome-stable

# Firefox
apt-get install -y firefox

# Edge
curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
install -o root -g root -m 644 microsoft.gpg /etc/apt/trusted.gpg.d/
sh -c 'echo "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/microsoft.gpg] https://packages.microsoft.com/repos/edge stable main" > /etc/apt/sources.list.d/microsoft-edge-dev.list'
apt-get update && apt-get install -y microsoft-edge-stable
```

### Testing Standards
- Test location: `/tests/manual/`
- Record all exploratory sessions
- Screenshot failures
- Link to test cases
- Maximum session: 2 hours

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_