# Story 5.6: Implement Geo-Routing

**Epic:** 5 - CBE Distribution  
**Story Number:** 5.6  
**Title:** Configure Geographic Traffic Routing  
**Status:** READY  
**Points:** 3  
**Component:** 536 (Geo-Routing)  

---

## Story

**As a** Global Operations Manager,  
**I want** intelligent geographic routing based on user location,  
**so that** users are served from the nearest datacenter with optimal performance and compliance.

---

## Acceptance Criteria

1. Geo-location detection accuracy > 95%
2. Routing decisions < 50ms
3. Compliance-aware routing for data sovereignty
4. Failover to next best region < 10 seconds
5. Support for 200+ country codes
6. Custom routing rules per region
7. A/B testing by geography
8. Real-time geo-analytics dashboard

---

## Tasks / Subtasks

### Task 1: Write Geo-Routing Tests (TDD) (AC: 1, 2, 4)
- [ ] Create `distribution/geo_routing_test.go`
  - [ ] Test location detection accuracy
  - [ ] Test routing speed
  - [ ] Test failover scenarios
  - [ ] Test compliance routing
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy Geo-Location Infrastructure (AC: 1, 5)
- [ ] Configure Azure Traffic Manager geographic routing
  ```hcl
  resource "azurerm_traffic_manager_profile" "geo" {
    name                   = "tm-oversight-geo"
    resource_group_name    = azurerm_resource_group.global.name
    traffic_routing_method = "Geographic"
    
    dns_config {
      relative_name = "geo-oversight"
      ttl          = 30
    }
    
    monitor_config {
      protocol                     = "HTTPS"
      port                        = 443
      path                        = "/health"
      interval_in_seconds         = 10
      timeout_in_seconds          = 5
      tolerated_number_of_failures = 2
    }
  }
  
  # Geographic routing for different regions
  resource "azurerm_traffic_manager_endpoint" "geo_us" {
    name                = "endpoint-us"
    resource_group_name = azurerm_resource_group.global.name
    profile_name        = azurerm_traffic_manager_profile.geo.name
    type               = "azureEndpoints"
    target_resource_id = azurerm_app_service.us_east.id
    
    geo_mapping = [
      "US",
      "CA",
      "MX"
    ]
  }
  
  resource "azurerm_traffic_manager_endpoint" "geo_eu" {
    name                = "endpoint-eu"
    resource_group_name = azurerm_resource_group.global.name
    profile_name        = azurerm_traffic_manager_profile.geo.name
    type               = "azureEndpoints"
    target_resource_id = azurerm_app_service.eu_west.id
    
    geo_mapping = [
      "GB",
      "DE",
      "FR",
      "IT",
      "ES",
      "NL",
      "BE",
      "CH",
      "AT",
      "PL",
      "CZ",
      "SK",
      "HU",
      "RO",
      "BG",
      "GR",
      "PT",
      "IE",
      "DK",
      "SE",
      "NO",
      "FI"
    ]
  }
  
  resource "azurerm_traffic_manager_endpoint" "geo_asia" {
    name                = "endpoint-asia"
    resource_group_name = azurerm_resource_group.global.name
    profile_name        = azurerm_traffic_manager_profile.geo.name
    type               = "azureEndpoints"
    target_resource_id = azurerm_app_service.asia_pacific.id
    
    geo_mapping = [
      "JP",
      "CN",
      "IN",
      "KR",
      "SG",
      "MY",
      "TH",
      "ID",
      "PH",
      "VN",
      "AU",
      "NZ"
    ]
  }
  
  # Default endpoint for unmapped countries
  resource "azurerm_traffic_manager_endpoint" "geo_default" {
    name                = "endpoint-default"
    resource_group_name = azurerm_resource_group.global.name
    profile_name        = azurerm_traffic_manager_profile.geo.name
    type               = "azureEndpoints"
    target_resource_id = azurerm_app_service.us_east.id
    
    geo_mapping = ["WORLD"]
  }
  ```
- [ ] Implement GeoIP detection
  ```javascript
  // services/geoip-detector.js
  class GeoIPDetector {
    constructor() {
      this.providers = {
        maxmind: new MaxMindProvider(),
        ipinfo: new IPInfoProvider(),
        azure: new AzureLocationProvider(),
        cloudflare: new CloudflareGeoProvider()
      };
      
      this.cache = new Map();
      this.accuracy = new Map();
    }
    
    async detectLocation(request) {
      const ip = this.extractIP(request);
      
      // Check cache
      const cached = this.cache.get(ip);
      if (cached && Date.now() - cached.timestamp < 3600000) {
        return cached.location;
      }
      
      // Try multiple providers for accuracy
      const detections = await Promise.allSettled([
        this.providers.maxmind.detect(ip),
        this.providers.ipinfo.detect(ip),
        this.providers.azure.detect(request),
        this.providers.cloudflare.detect(request)
      ]);
      
      // Aggregate results
      const location = this.aggregateDetections(detections);
      
      // Validate and enhance
      const enhanced = await this.enhanceLocation(location);
      
      // Cache result
      this.cache.set(ip, {
        location: enhanced,
        timestamp: Date.now()
      });
      
      // Track accuracy
      this.trackAccuracy(ip, detections);
      
      return enhanced;
    }
    
    aggregateDetections(detections) {
      const successful = detections
        .filter(d => d.status === 'fulfilled')
        .map(d => d.value);
      
      if (successful.length === 0) {
        return { country: 'UNKNOWN', confidence: 0 };
      }
      
      // Vote on country
      const countryVotes = {};
      successful.forEach(detection => {
        const country = detection.country;
        countryVotes[country] = (countryVotes[country] || 0) + 1;
      });
      
      // Get most voted country
      const topCountry = Object.entries(countryVotes)
        .sort((a, b) => b[1] - a[1])[0];
      
      // Calculate confidence
      const confidence = topCountry[1] / successful.length;
      
      // Aggregate other fields
      const location = {
        country: topCountry[0],
        confidence,
        city: this.mostCommon(successful.map(s => s.city)),
        region: this.mostCommon(successful.map(s => s.region)),
        latitude: this.average(successful.map(s => s.latitude).filter(Boolean)),
        longitude: this.average(successful.map(s => s.longitude).filter(Boolean)),
        timezone: this.mostCommon(successful.map(s => s.timezone)),
        asn: this.mostCommon(successful.map(s => s.asn)),
        isp: this.mostCommon(successful.map(s => s.isp))
      };
      
      return location;
    }
    
    async enhanceLocation(location) {
      // Add additional metadata
      const enhanced = { ...location };
      
      // Add continent
      enhanced.continent = this.getContinent(location.country);
      
      // Add compliance region
      enhanced.complianceRegion = await this.getComplianceRegion(location.country);
      
      // Add network quality indicators
      enhanced.networkQuality = await this.assessNetworkQuality(location);
      
      // Add language preferences
      enhanced.languages = this.getLanguages(location.country);
      
      // Add currency
      enhanced.currency = this.getCurrency(location.country);
      
      // Add datacenter proximity
      enhanced.nearestDatacenter = await this.getNearestDatacenter(location);
      
      return enhanced;
    }
    
    extractIP(request) {
      // Check various headers for real IP
      const headers = [
        'x-forwarded-for',
        'x-real-ip',
        'cf-connecting-ip',
        'true-client-ip',
        'x-client-ip'
      ];
      
      for (const header of headers) {
        const value = request.headers[header];
        if (value) {
          // Handle comma-separated list
          const ips = value.split(',').map(ip => ip.trim());
          // Return first public IP
          return ips.find(ip => !this.isPrivateIP(ip)) || ips[0];
        }
      }
      
      return request.connection.remoteAddress;
    }
    
    isPrivateIP(ip) {
      const parts = ip.split('.');
      return (
        parts[0] === '10' ||
        (parts[0] === '172' && parts[1] >= 16 && parts[1] <= 31) ||
        (parts[0] === '192' && parts[1] === '168') ||
        ip === '127.0.0.1' ||
        ip === '::1'
      );
    }
  }
  ```
- [ ] Configure location databases
- [ ] Setup accuracy monitoring

### Task 3: Implement Routing Logic (AC: 2, 6)
- [ ] Create geo-router service
  ```javascript
  // services/geo-router.js
  class GeoRouter {
    constructor() {
      this.routingTable = new Map();
      this.customRules = new Map();
      this.datacenters = this.loadDatacenters();
    }
    
    async route(request) {
      const startTime = Date.now();
      
      // Detect location
      const location = await this.geoDetector.detectLocation(request);
      
      // Check custom rules first
      const customRoute = await this.checkCustomRules(request, location);
      if (customRoute) {
        return this.finalizeRoute(customRoute, Date.now() - startTime);
      }
      
      // Check compliance requirements
      const complianceRoute = await this.checkCompliance(request, location);
      if (complianceRoute) {
        return this.finalizeRoute(complianceRoute, Date.now() - startTime);
      }
      
      // Calculate optimal route
      const optimalRoute = await this.calculateOptimalRoute(location);
      
      // Apply business rules
      const finalRoute = await this.applyBusinessRules(optimalRoute, request);
      
      return this.finalizeRoute(finalRoute, Date.now() - startTime);
    }
    
    async calculateOptimalRoute(location) {
      // Get available datacenters
      const available = await this.getHealthyDatacenters();
      
      // Calculate scores for each datacenter
      const scores = await Promise.all(
        available.map(async dc => {
          const score = await this.calculateScore(dc, location);
          return { datacenter: dc, score };
        })
      );
      
      // Sort by score
      scores.sort((a, b) => b.score - a.score);
      
      // Return best match
      return {
        primary: scores[0].datacenter,
        fallback: scores[1]?.datacenter,
        allOptions: scores
      };
    }
    
    async calculateScore(datacenter, location) {
      const factors = {
        // Geographic proximity (40%)
        distance: this.calculateDistance(
          datacenter.location,
          { lat: location.latitude, lng: location.longitude }
        ),
        
        // Network latency (30%)
        latency: await this.estimateLatency(location, datacenter),
        
        // Capacity (15%)
        capacity: await this.getAvailableCapacity(datacenter),
        
        // Cost (10%)
        cost: this.calculateCost(location, datacenter),
        
        // Compliance (5%)
        compliance: this.checkDatacenterCompliance(location, datacenter)
      };
      
      // Normalize and weight factors
      const weights = {
        distance: 0.4,
        latency: 0.3,
        capacity: 0.15,
        cost: 0.1,
        compliance: 0.05
      };
      
      let score = 0;
      
      // Distance score (inverse)
      score += weights.distance * (1 - Math.min(1, factors.distance / 10000));
      
      // Latency score (inverse)
      score += weights.latency * (1 - Math.min(1, factors.latency / 500));
      
      // Capacity score
      score += weights.capacity * factors.capacity;
      
      // Cost score (inverse)
      score += weights.cost * (1 - factors.cost);
      
      // Compliance score
      score += weights.compliance * (factors.compliance ? 1 : 0);
      
      return score;
    }
    
    calculateDistance(point1, point2) {
      // Haversine formula
      const R = 6371; // Earth radius in km
      const dLat = this.toRad(point2.lat - point1.lat);
      const dLng = this.toRad(point2.lng - point1.lng);
      
      const a = 
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(this.toRad(point1.lat)) * Math.cos(this.toRad(point2.lat)) *
        Math.sin(dLng / 2) * Math.sin(dLng / 2);
      
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      
      return R * c;
    }
    
    async checkCustomRules(request, location) {
      const rules = this.customRules.get(location.country) || [];
      
      for (const rule of rules) {
        if (await rule.evaluate(request, location)) {
          return {
            datacenter: rule.targetDatacenter,
            reason: rule.reason,
            rule: rule.name
          };
        }
      }
      
      return null;
    }
    
    async applyBusinessRules(route, request) {
      // Premium users get fastest route
      if (request.user?.tier === 'premium') {
        return route;
      }
      
      // Free users might get cost-optimized route
      if (request.user?.tier === 'free') {
        const costOptimized = route.allOptions
          .sort((a, b) => this.calculateCost(a) - this.calculateCost(b))[0];
        
        if (costOptimized !== route.primary) {
          route.primary = costOptimized.datacenter;
          route.reason = 'cost_optimized';
        }
      }
      
      return route;
    }
    
    finalizeRoute(route, decisionTime) {
      // Add metadata
      route.decisionTime = decisionTime;
      route.timestamp = new Date();
      
      // Set headers
      route.headers = {
        'X-Geo-Route': route.primary.region,
        'X-Geo-Country': route.location?.country,
        'X-Route-Reason': route.reason || 'optimal',
        'X-Decision-Time': decisionTime + 'ms'
      };
      
      // Log routing decision
      this.logRoutingDecision(route);
      
      return route;
    }
  }
  ```
- [ ] Configure routing rules
- [ ] Setup custom policies
- [ ] Test routing decisions

### Task 4: Implement Compliance Routing (AC: 3)
- [ ] Configure data sovereignty rules
  ```javascript
  // services/compliance-router.js
  class ComplianceRouter {
    constructor() {
      this.regulations = {
        GDPR: {
          applies: ['EU', 'EEA'],
          requirements: {
            dataLocation: 'EU',
            encryption: 'required',
            audit: 'required'
          }
        },
        CCPA: {
          applies: ['US-CA'],
          requirements: {
            dataLocation: 'US',
            optOut: 'required'
          }
        },
        PIPEDA: {
          applies: ['CA'],
          requirements: {
            dataLocation: 'CA',
            consent: 'required'
          }
        },
        LGPD: {
          applies: ['BR'],
          requirements: {
            dataLocation: 'BR',
            consent: 'required'
          }
        },
        PDPA: {
          applies: ['SG'],
          requirements: {
            dataLocation: 'SG',
            consent: 'required'
          }
        },
        'Data Localization': {
          applies: ['RU', 'CN', 'IN'],
          requirements: {
            dataLocation: 'same_country',
            audit: 'required'
          }
        }
      };
    }
    
    async checkCompliance(request, location) {
      const applicable = this.getApplicableRegulations(location);
      
      if (applicable.length === 0) {
        return null;
      }
      
      // Find compliant datacenters
      const compliantDatacenters = await this.getCompliantDatacenters(applicable);
      
      if (compliantDatacenters.length === 0) {
        // Log compliance issue
        await this.logComplianceIssue({
          location,
          regulations: applicable,
          issue: 'No compliant datacenter available'
        });
        
        // Fallback with warning
        return {
          datacenter: this.getDefaultDatacenter(),
          warning: 'Compliance requirements could not be fully met',
          regulations: applicable
        };
      }
      
      // Select best compliant datacenter
      const selected = await this.selectBestCompliant(compliantDatacenters, location);
      
      return {
        datacenter: selected,
        reason: 'compliance',
        regulations: applicable,
        compliant: true
      };
    }
    
    getApplicableRegulations(location) {
      const applicable = [];
      
      for (const [name, regulation] of Object.entries(this.regulations)) {
        if (this.regulationApplies(regulation, location)) {
          applicable.push({
            name,
            requirements: regulation.requirements
          });
        }
      }
      
      return applicable;
    }
    
    regulationApplies(regulation, location) {
      // Check country
      if (regulation.applies.includes(location.country)) {
        return true;
      }
      
      // Check region (e.g., EU)
      if (regulation.applies.includes(location.complianceRegion)) {
        return true;
      }
      
      // Check state (e.g., US-CA for California)
      if (regulation.applies.includes(`${location.country}-${location.region}`)) {
        return true;
      }
      
      return false;
    }
    
    async getCompliantDatacenters(regulations) {
      const datacenters = await this.getAllDatacenters();
      const compliant = [];
      
      for (const dc of datacenters) {
        if (await this.isDatacenterCompliant(dc, regulations)) {
          compliant.push(dc);
        }
      }
      
      return compliant;
    }
    
    async isDatacenterCompliant(datacenter, regulations) {
      for (const regulation of regulations) {
        // Check data location requirement
        if (regulation.requirements.dataLocation) {
          if (regulation.requirements.dataLocation === 'same_country') {
            // Need country-specific check
            if (datacenter.country !== regulation.applies[0]) {
              return false;
            }
          } else if (regulation.requirements.dataLocation !== datacenter.region &&
                     regulation.requirements.dataLocation !== datacenter.country) {
            return false;
          }
        }
        
        // Check encryption requirement
        if (regulation.requirements.encryption === 'required') {
          if (!datacenter.features.encryption) {
            return false;
          }
        }
        
        // Check audit requirement
        if (regulation.requirements.audit === 'required') {
          if (!datacenter.features.audit) {
            return false;
          }
        }
      }
      
      return true;
    }
    
    async handleDataRequest(request, location) {
      // Handle data subject requests based on location
      const regulations = this.getApplicableRegulations(location);
      
      for (const regulation of regulations) {
        switch (regulation.name) {
          case 'GDPR':
            return await this.handleGDPRRequest(request);
          
          case 'CCPA':
            return await this.handleCCPARequest(request);
          
          case 'LGPD':
            return await this.handleLGPDRequest(request);
          
          default:
            return await this.handleGenericRequest(request);
        }
      }
    }
  }
  ```
- [ ] Setup data residency rules
- [ ] Configure audit logging
- [ ] Test compliance routing

### Task 5: Implement Failover (AC: 4)
- [ ] Configure automatic failover
  ```javascript
  // services/geo-failover.js
  class GeoFailover {
    constructor() {
      this.healthChecks = new Map();
      this.failoverHistory = [];
      this.failoverInProgress = new Set();
    }
    
    async monitorHealth() {
      setInterval(async () => {
        const datacenters = await this.getAllDatacenters();
        
        for (const dc of datacenters) {
          const health = await this.checkHealth(dc);
          this.updateHealthStatus(dc, health);
          
          if (!health.healthy && !this.failoverInProgress.has(dc.id)) {
            await this.initiateFailover(dc);
          }
        }
      }, 5000); // Check every 5 seconds
    }
    
    async checkHealth(datacenter) {
      const checks = await Promise.allSettled([
        this.httpHealthCheck(datacenter),
        this.tcpHealthCheck(datacenter),
        this.dnsHealthCheck(datacenter),
        this.applicationHealthCheck(datacenter)
      ]);
      
      const successful = checks.filter(c => 
        c.status === 'fulfilled' && c.value.healthy
      ).length;
      
      return {
        healthy: successful >= 3, // Require 3/4 checks to pass
        checks: checks.map(c => c.value || { healthy: false }),
        timestamp: Date.now()
      };
    }
    
    async initiateFailover(failedDatacenter) {
      console.log(`Initiating failover for ${failedDatacenter.name}`);
      const startTime = Date.now();
      
      this.failoverInProgress.add(failedDatacenter.id);
      
      const failover = {
        id: this.generateId(),
        datacenter: failedDatacenter,
        startTime,
        status: 'in_progress'
      };
      
      try {
        // Find replacement datacenter
        const replacement = await this.findReplacement(failedDatacenter);
        
        if (!replacement) {
          throw new Error('No suitable replacement datacenter available');
        }
        
        // Update routing
        await this.updateRouting(failedDatacenter, replacement);
        
        // Migrate active sessions
        await this.migrateSessions(failedDatacenter, replacement);
        
        // Update DNS
        await this.updateDNS(failedDatacenter, replacement);
        
        // Verify failover
        await this.verifyFailover(replacement);
        
        failover.replacement = replacement;
        failover.completionTime = Date.now() - startTime;
        failover.status = 'completed';
        
        console.log(`Failover completed in ${failover.completionTime}ms`);
        
        // Check if we met SLA
        if (failover.completionTime > 10000) {
          await this.reportSLAViolation(failover);
        }
        
      } catch (error) {
        failover.status = 'failed';
        failover.error = error.message;
        
        // Try emergency failover
        await this.emergencyFailover(failedDatacenter);
        
      } finally {
        this.failoverInProgress.delete(failedDatacenter.id);
        this.failoverHistory.push(failover);
      }
      
      return failover;
    }
    
    async findReplacement(failed) {
      // Get healthy datacenters
      const healthy = await this.getHealthyDatacenters();
      
      // Filter by region for compliance
      const sameRegion = healthy.filter(dc => 
        dc.complianceRegion === failed.complianceRegion
      );
      
      if (sameRegion.length > 0) {
        // Prefer same compliance region
        return this.selectBest(sameRegion, failed);
      }
      
      // Fallback to nearest datacenter
      return this.findNearest(healthy, failed);
    }
    
    async updateRouting(from, to) {
      // Update Traffic Manager
      await this.trafficManager.updateEndpoint(from.id, {
        enabled: false,
        priority: 999
      });
      
      await this.trafficManager.updateEndpoint(to.id, {
        enabled: true,
        priority: from.originalPriority
      });
      
      // Update CDN origin
      await this.cdn.updateOrigin(from.id, {
        enabled: false
      });
      
      await this.cdn.updateOrigin(to.id, {
        enabled: true,
        priority: 1
      });
    }
    
    async migrateSessions(from, to) {
      // Get active sessions
      const sessions = await this.getActiveSessions(from);
      
      console.log(`Migrating ${sessions.length} sessions`);
      
      // Migrate in batches
      const batchSize = 100;
      for (let i = 0; i < sessions.length; i += batchSize) {
        const batch = sessions.slice(i, i + batchSize);
        
        await Promise.all(
          batch.map(session => this.migrateSession(session, to))
        );
      }
    }
  }
  ```
- [ ] Setup health monitoring
- [ ] Configure failover triggers
- [ ] Test failover speed

### Task 6: Create Custom Routing Rules (AC: 6)
- [ ] Implement rule engine
  ```javascript
  // services/routing-rules.js
  class RoutingRuleEngine {
    constructor() {
      this.rules = [];
      this.cache = new Map();
    }
    
    addRule(rule) {
      // Validate rule
      this.validateRule(rule);
      
      // Add to rules list
      this.rules.push({
        id: this.generateId(),
        ...rule,
        created: new Date(),
        enabled: true
      });
      
      // Sort by priority
      this.rules.sort((a, b) => a.priority - b.priority);
      
      // Clear cache
      this.cache.clear();
    }
    
    async evaluate(request, location) {
      const cacheKey = `${location.country}:${request.path}`;
      
      // Check cache
      const cached = this.cache.get(cacheKey);
      if (cached) {
        return cached;
      }
      
      // Evaluate rules in priority order
      for (const rule of this.rules) {
        if (!rule.enabled) continue;
        
        if (await this.matchesConditions(rule.conditions, request, location)) {
          const result = {
            datacenter: rule.targetDatacenter,
            rule: rule.id,
            reason: rule.name
          };
          
          // Cache result
          this.cache.set(cacheKey, result);
          
          return result;
        }
      }
      
      return null;
    }
    
    async matchesConditions(conditions, request, location) {
      for (const condition of conditions) {
        const matches = await this.evaluateCondition(condition, request, location);
        
        if (!matches) {
          return false;
        }
      }
      
      return true;
    }
    
    async evaluateCondition(condition, request, location) {
      switch (condition.type) {
        case 'country':
          return this.matchCountry(condition, location);
        
        case 'region':
          return this.matchRegion(condition, location);
        
        case 'city':
          return this.matchCity(condition, location);
        
        case 'asn':
          return this.matchASN(condition, location);
        
        case 'time':
          return this.matchTime(condition);
        
        case 'user_segment':
          return this.matchUserSegment(condition, request);
        
        case 'path':
          return this.matchPath(condition, request);
        
        case 'header':
          return this.matchHeader(condition, request);
        
        case 'percentage':
          return this.matchPercentage(condition, request);
        
        default:
          return false;
      }
    }
    
    matchCountry(condition, location) {
      if (condition.operator === 'in') {
        return condition.values.includes(location.country);
      }
      if (condition.operator === 'not_in') {
        return !condition.values.includes(location.country);
      }
      return false;
    }
    
    matchPercentage(condition, request) {
      // Hash request for consistent routing
      const hash = this.hashRequest(request);
      const bucket = hash % 100;
      
      return bucket < condition.value;
    }
    
    // Example rules
    getExampleRules() {
      return [
        {
          name: 'EU GDPR Compliance',
          priority: 1,
          conditions: [
            { type: 'region', operator: 'in', values: ['EU'] }
          ],
          targetDatacenter: 'eu-west-1'
        },
        {
          name: 'China Great Firewall',
          priority: 2,
          conditions: [
            { type: 'country', operator: 'in', values: ['CN'] }
          ],
          targetDatacenter: 'cn-north-1'
        },
        {
          name: 'Premium US East',
          priority: 10,
          conditions: [
            { type: 'country', operator: 'in', values: ['US'] },
            { type: 'user_segment', operator: 'equals', value: 'premium' }
          ],
          targetDatacenter: 'us-east-1'
        },
        {
          name: 'A/B Test Asia',
          priority: 20,
          conditions: [
            { type: 'region', operator: 'in', values: ['ASIA'] },
            { type: 'percentage', value: 50 }
          ],
          targetDatacenter: 'asia-southeast-2'
        }
      ];
    }
  }
  ```
- [ ] Configure rule management UI
- [ ] Setup rule validation
- [ ] Test rule evaluation

### Task 7: Enable Geographic A/B Testing (AC: 7)
- [ ] Implement geo-based experiments
  ```javascript
  // services/geo-experiments.js
  class GeoExperiments {
    constructor() {
      this.experiments = new Map();
      this.assignments = new Map();
    }
    
    async createExperiment(config) {
      const experiment = {
        id: this.generateId(),
        name: config.name,
        startTime: new Date(),
        endTime: config.endTime,
        status: 'active',
        geoTargeting: config.geoTargeting,
        variants: config.variants,
        metrics: {
          impressions: {},
          conversions: {}
        }
      };
      
      // Validate geo targeting
      this.validateGeoTargeting(experiment.geoTargeting);
      
      // Validate traffic split
      this.validateTrafficSplit(experiment.variants);
      
      this.experiments.set(experiment.id, experiment);
      
      return experiment;
    }
    
    async assignVariant(request, location) {
      // Check for active geo experiments
      const applicable = this.getApplicableExperiments(location);
      
      if (applicable.length === 0) {
        return null;
      }
      
      // Get or create assignment
      const userId = request.userId || request.sessionId;
      const assignment = this.assignments.get(userId) || {};
      
      for (const experiment of applicable) {
        // Check if already assigned
        if (assignment[experiment.id]) {
          continue;
        }
        
        // Assign variant
        const variant = this.selectVariant(experiment, location, userId);
        assignment[experiment.id] = {
          variant,
          timestamp: Date.now(),
          location: location.country
        };
        
        // Track impression
        this.trackImpression(experiment, variant, location);
      }
      
      this.assignments.set(userId, assignment);
      
      return assignment;
    }
    
    getApplicableExperiments(location) {
      const active = [];
      
      for (const [id, experiment] of this.experiments) {
        if (experiment.status !== 'active') continue;
        
        // Check geo targeting
        if (this.matchesGeoTargeting(experiment.geoTargeting, location)) {
          active.push(experiment);
        }
      }
      
      return active;
    }
    
    matchesGeoTargeting(targeting, location) {
      if (targeting.type === 'countries') {
        return targeting.values.includes(location.country);
      }
      
      if (targeting.type === 'regions') {
        return targeting.values.includes(location.continent);
      }
      
      if (targeting.type === 'cities') {
        return targeting.values.includes(location.city);
      }
      
      if (targeting.type === 'radius') {
        const distance = this.calculateDistance(
          targeting.center,
          { lat: location.latitude, lng: location.longitude }
        );
        return distance <= targeting.radius;
      }
      
      return false;
    }
    
    selectVariant(experiment, location, userId) {
      // Use consistent hashing for assignment
      const hash = this.hashUser(userId + experiment.id);
      const bucket = hash % 100;
      
      let cumulative = 0;
      for (const variant of experiment.variants) {
        cumulative += variant.traffic;
        
        if (bucket < cumulative) {
          return variant;
        }
      }
      
      return experiment.variants[0]; // Default to control
    }
    
    async trackConversion(userId, experimentId, value) {
      const assignment = this.assignments.get(userId)?.[experimentId];
      
      if (!assignment) {
        return;
      }
      
      const experiment = this.experiments.get(experimentId);
      
      if (!experiment) {
        return;
      }
      
      // Update metrics
      const variant = assignment.variant;
      experiment.metrics.conversions[variant.id] = 
        (experiment.metrics.conversions[variant.id] || 0) + 1;
      
      // Track geo-specific conversion
      const geoKey = `${variant.id}:${assignment.location}`;
      experiment.metrics.geoConversions = experiment.metrics.geoConversions || {};
      experiment.metrics.geoConversions[geoKey] = 
        (experiment.metrics.geoConversions[geoKey] || 0) + 1;
      
      // Calculate statistics
      await this.calculateStatistics(experiment);
    }
    
    async getResults(experimentId) {
      const experiment = this.experiments.get(experimentId);
      
      if (!experiment) {
        return null;
      }
      
      const results = {
        experiment: {
          id: experiment.id,
          name: experiment.name,
          status: experiment.status
        },
        variants: [],
        geographic: {},
        statistics: await this.calculateStatistics(experiment)
      };
      
      // Aggregate by variant
      for (const variant of experiment.variants) {
        const impressions = experiment.metrics.impressions[variant.id] || 0;
        const conversions = experiment.metrics.conversions[variant.id] || 0;
        
        results.variants.push({
          id: variant.id,
          name: variant.name,
          impressions,
          conversions,
          conversionRate: impressions > 0 ? conversions / impressions : 0
        });
      }
      
      // Aggregate by geography
      for (const [geoKey, count] of Object.entries(experiment.metrics.geoConversions || {})) {
        const [variantId, country] = geoKey.split(':');
        
        if (!results.geographic[country]) {
          results.geographic[country] = {};
        }
        
        results.geographic[country][variantId] = count;
      }
      
      return results;
    }
  }
  ```
- [ ] Setup experiment tracking
- [ ] Configure metrics collection
- [ ] Test geo experiments

### Task 8: Create Analytics Dashboard (AC: 8)
- [ ] Build geo-analytics dashboard
  ```javascript
  // services/geo-analytics.js
  class GeoAnalytics {
    async generateDashboard() {
      const [
        trafficMap,
        routingMetrics,
        complianceStatus,
        performanceByRegion,
        experiments,
        failoverHistory
      ] = await Promise.all([
        this.getTrafficMap(),
        this.getRoutingMetrics(),
        this.getComplianceStatus(),
        this.getPerformanceByRegion(),
        this.getActiveExperiments(),
        this.getFailoverHistory()
      ]);
      
      return {
        map: trafficMap,
        routing: routingMetrics,
        compliance: complianceStatus,
        performance: performanceByRegion,
        experiments,
        failovers: failoverHistory,
        generated: new Date()
      };
    }
    
    async getTrafficMap() {
      const traffic = await this.aggregateTrafficByCountry();
      
      return {
        type: 'choropleth',
        data: traffic.map(t => ({
          country: t.country,
          value: t.requests,
          users: t.uniqueUsers,
          revenue: t.revenue,
          datacenter: t.routedTo
        })),
        heatmap: await this.generateHeatmap(traffic)
      };
    }
    
    async getRoutingMetrics() {
      const decisions = await this.getRoutingDecisions(3600000); // Last hour
      
      return {
        totalDecisions: decisions.length,
        avgDecisionTime: this.average(decisions.map(d => d.decisionTime)),
        p99DecisionTime: this.percentile(decisions.map(d => d.decisionTime), 99),
        routingReasons: this.groupBy(decisions, 'reason'),
        datacenterDistribution: this.groupBy(decisions, 'datacenter'),
        complianceRouting: decisions.filter(d => d.reason === 'compliance').length,
        customRules: decisions.filter(d => d.rule).length
      };
    }
    
    async getPerformanceByRegion() {
      const regions = ['US', 'EU', 'ASIA', 'LATAM', 'AFRICA'];
      const performance = {};
      
      for (const region of regions) {
        const metrics = await this.getRegionMetrics(region);
        
        performance[region] = {
          latency: {
            p50: metrics.latency.p50,
            p95: metrics.latency.p95,
            p99: metrics.latency.p99
          },
          availability: metrics.availability,
          throughput: metrics.throughput,
          errorRate: metrics.errorRate,
          users: metrics.uniqueUsers,
          trend: this.calculateTrend(metrics.history)
        };
      }
      
      return performance;
    }
    
    async generateReport() {
      const report = {
        period: {
          start: new Date(Date.now() - 7 * 24 * 3600000),
          end: new Date()
        },
        summary: await this.getSummary(),
        geographic: await this.getGeographicBreakdown(),
        routing: await this.getRoutingAnalysis(),
        compliance: await this.getComplianceReport(),
        performance: await this.getPerformanceReport(),
        experiments: await this.getExperimentResults(),
        recommendations: await this.generateRecommendations()
      };
      
      return report;
    }
  }
  ```
- [ ] Setup real-time updates
- [ ] Configure export functionality
- [ ] Create visualization components

---

## Dev Notes

### Geo-Routing Configuration
```
Primary: Geographic proximity
Secondary: Network latency
Tertiary: Available capacity
Override: Compliance requirements
```

### Country Code Mapping
```
ISO 3166-1 alpha-2 codes
Special regions:
- EU: European Union members
- ASIA: All Asian countries
- LATAM: Latin America
- WORLD: Default/fallback
```

### Compliance Regions
```
GDPR: EU + EEA countries
CCPA: California, USA
Data Localization: Russia, China, India
Default: No restrictions
```

### Failover Priority
1. Same compliance region
2. Same continent
3. Lowest latency
4. Highest capacity

### Testing Standards
- Test location: `/tests/distribution/geo-routing/`
- Test with VPN/proxy IPs
- Verify compliance routing
- Test failover < 10 seconds
- Check A/B test distribution

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_