# Story 1.5: Deploy Dummy Test Application

**Epic:** 1 - Secure Access Infrastructure  
**Story Number:** 1.5  
**Title:** Create and Deploy Dummy Test Application  
**Status:** READY  
**Points:** 3  
**Component:** 401 (Test Container Instance)  

---

## Story

**As a** DevOps Engineer,  
**I want** to deploy a simple containerized test application,  
**so that** I can validate the secure network routing and access controls are working correctly.

---

## Acceptance Criteria

1. Simple Node.js/Python app that returns "Hello Secure World" on GET /
2. Health endpoint returns 200 OK on GET /health
3. App deployed as Azure Container Instance in test subnet (10.40.1.0/24)
4. No public IP assigned to the container
5. Application accessible only through App Gateway -> Firewall -> Container
6. Container image stored in Azure Container Registry
7. Environment variables configured for test environment
8. All tests pass before deployment
9. Monitoring and logs configured

---

## Tasks / Subtasks

### Task 1: Write Application Tests First (TDD) (AC: 8)
- [ ] Create `/tests/integration/dummy_app_test.go`
  - [ ] Test app responds on root endpoint
  - [ ] Test health endpoint returns 200
  - [ ] Test app is not publicly accessible
  - [ ] Test app is accessible through gateway
- [ ] Create unit tests for the app itself
  - [ ] Test route handlers
  - [ ] Test error handling
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Create Dummy Application (AC: 1, 2)
- [ ] Create `/apps/dummy-test-app/` directory
- [ ] Create simple Express.js or FastAPI app
  ```javascript
  // app.js example
  const express = require('express');
  const app = express();
  
  app.get('/', (req, res) => {
    res.json({ message: 'Hello Secure World', 
               environment: process.env.NODE_ENV,
               version: process.env.APP_VERSION || '1.0.0' });
  });
  
  app.get('/health', (req, res) => {
    res.status(200).json({ status: 'healthy' });
  });
  ```
- [ ] Create package.json with dependencies
- [ ] Add basic error handling
- [ ] Add request logging

### Task 3: Containerize Application (AC: 6)
- [ ] Create multi-stage Dockerfile
  ```dockerfile
  # Build stage
  FROM node:18-alpine AS builder
  WORKDIR /app
  COPY package*.json ./
  RUN npm ci --only=production
  
  # Runtime stage  
  FROM node:18-alpine
  WORKDIR /app
  COPY --from=builder /app/node_modules ./node_modules
  COPY . .
  EXPOSE 3000
  USER node
  CMD ["node", "app.js"]
  ```
- [ ] Create .dockerignore file
- [ ] Build and test container locally
- [ ] Scan image for vulnerabilities

### Task 4: Push to Azure Container Registry (AC: 6)
- [ ] Build container image
  - [ ] Tag with version and latest
  - [ ] Include git commit hash in metadata
- [ ] Push to ACR (10.60.3.0/24)
  ```bash
  az acr build --registry acrsecdevopsdev \
    --image dummy-app:v1.0.0 \
    --image dummy-app:latest .
  ```
- [ ] Verify image in registry
- [ ] Set up automated build on commit

### Task 5: Deploy as Container Instance (AC: 3, 4, 7)
- [ ] Create `/terraform/modules/test-app/main.tf`
  ```hcl
  resource "azurerm_container_group" "dummy_app" {
    name                = "aci-dummy-test-app"
    location            = var.location
    resource_group_name = var.resource_group_name
    ip_address_type     = "Private"
    subnet_ids          = [var.subnet_id]
    os_type            = "Linux"
    
    container {
      name   = "dummy-app"
      image  = "${var.acr_login_server}/dummy-app:latest"
      cpu    = "0.5"
      memory = "1.0"
      
      ports {
        port     = 3000
        protocol = "TCP"
      }
      
      environment_variables = {
        NODE_ENV    = "test"
        APP_VERSION = var.app_version
        VAULT_ADDR  = "http://10.40.2.10:8200"
      }
    }
  }
  ```
- [ ] Configure container group settings
- [ ] Set resource limits appropriately
- [ ] Configure restart policy

### Task 6: Configure Application Gateway Backend (AC: 5)
- [ ] Add backend pool for dummy app
  - [ ] Point to container instance private IP
  - [ ] Configure health probe for /health
- [ ] Create routing rule
  - [ ] Path-based routing if needed
  - [ ] Configure request routing rules
- [ ] Test routing through gateway

### Task 7: Setup Monitoring (AC: 9)
- [ ] Configure container logs
  - [ ] Send to Log Analytics workspace
  - [ ] Set log retention
- [ ] Create application insights
  - [ ] Add instrumentation to app
  - [ ] Track custom metrics
- [ ] Set up alerts
  - [ ] Alert on app errors
  - [ ] Alert on high response time
  - [ ] Alert on container restarts

### Task 8: Integration Testing (AC: 5, 8)
- [ ] Test access from outside (should fail)
  ```bash
  # Should timeout or connection refused
  curl http://10.40.1.10:3000
  ```
- [ ] Test access through App Gateway (should work)
  ```bash
  # Should return "Hello Secure World"
  curl https://172.178.53.198
  ```
- [ ] Validate firewall logs show traffic
- [ ] Document access patterns

---

## Dev Notes

### Application Structure
```
/apps/dummy-test-app/
├── app.js                 # Main application
├── package.json           # Dependencies
├── package-lock.json      # Lock file
├── Dockerfile            # Container definition
├── .dockerignore         # Build exclusions
├── tests/
│   ├── unit/
│   │   └── app.test.js   # Unit tests
│   └── integration/
│       └── routes.test.js # Integration tests
└── README.md             # Documentation
```

### Environment Variables
```yaml
NODE_ENV: test
APP_VERSION: 1.0.0
PORT: 3000
LOG_LEVEL: info
VAULT_ADDR: http://10.40.2.10:8200
APP_INSIGHTS_KEY: <from keyvault>
```

### Testing the Secure Path
```bash
# 1. Test direct access (should fail)
curl -v http://10.40.1.10:3000
# Expected: timeout

# 2. Test through App Gateway
curl -v https://172.178.53.198
# Expected: 200 OK with "Hello Secure World"

# 3. Test health endpoint
curl -v https://172.178.53.198/health
# Expected: 200 OK with {"status": "healthy"}

# 4. Test with unauthorized IP (should be blocked by NSG)
# From non-whitelisted IP
curl -v https://172.178.53.198
# Expected: connection refused
```

### Container Registry Commands
```bash
# Login to ACR
az acr login --name acrsecdevopsdev

# Build and push
az acr build --registry acrsecdevopsdev \
  --image dummy-app:v1.0.0 \
  --file Dockerfile .

# List images
az acr repository list --name acrsecdevopsdev

# Show tags
az acr repository show-tags --name acrsecdevopsdev \
  --repository dummy-app
```

### Monitoring Queries
```kusto
// Application logs
ContainerInstanceLog_CL
| where ContainerGroup_s == "aci-dummy-test-app"
| where Message contains "GET /"
| summarize count() by bin(TimeGenerated, 5m)

// Application errors
ContainerInstanceLog_CL
| where ContainerGroup_s == "aci-dummy-test-app"
| where Message contains "error" or Message contains "Error"
| project TimeGenerated, Message
```

### Testing Standards
- Test location: `/tests/integration/`
- Use Terratest for infrastructure tests
- Use Jest/Mocha for application unit tests
- Validate secure routing path works
- Ensure no public access is possible

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_