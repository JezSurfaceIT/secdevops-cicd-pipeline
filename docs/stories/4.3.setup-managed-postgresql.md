# Story 4.3: Setup Managed PostgreSQL

**Epic:** 4 - Production SaaS Deployment  
**Story Number:** 4.3  
**Title:** Deploy Azure Database for PostgreSQL  
**Status:** READY  
**Points:** 3  
**Component:** 711 (Managed PostgreSQL)  

---

## Story

**As a** Database Administrator,  
**I want** a managed PostgreSQL database with high availability,  
**so that** we have a reliable, scalable database with automatic backups and failover.

---

## Acceptance Criteria

1. Azure Database for PostgreSQL Flexible Server deployed
2. General Purpose tier with 4 vCores minimum
3. High Availability with zone redundancy enabled
4. Automated backups with 7-day retention
5. Private endpoint configured (10.20.3.0/24)
6. Connection pooling configured with PgBouncer
7. Read replicas for reporting workloads
8. Performance monitoring and query insights enabled

---

## Tasks / Subtasks

### Task 1: Write Database Tests (TDD) (AC: 1, 3, 5)
- [ ] Create `production/postgresql_test.go`
  - [ ] Test database server exists
  - [ ] Test HA is configured
  - [ ] Test private endpoint works
  - [ ] Test connection from app
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy PostgreSQL Infrastructure (AC: 1, 2, 3)
- [ ] Create PostgreSQL Flexible Server
  ```hcl
  resource "azurerm_postgresql_flexible_server" "main" {
    name                = "psql-oversight-prod"
    location            = var.location
    resource_group_name = "rg-oversight-prod-saas-eastus"
    
    administrator_login    = "psqladmin"
    administrator_password = azurerm_key_vault_secret.db_admin_password.value
    
    sku_name   = "GP_Standard_D4s_v3"
    version    = "14"
    storage_mb = 131072  # 128GB
    
    # High Availability
    high_availability {
      mode                      = "ZoneRedundant"
      standby_availability_zone = "2"
    }
    
    # Backup configuration
    backup_retention_days        = 7
    geo_redundant_backup_enabled = true
    
    # Maintenance window
    maintenance_window {
      day_of_week  = 0  # Sunday
      start_hour   = 2
      start_minute = 0
    }
    
    zone = "1"
    
    tags = {
      environment = "production"
      component   = "database"
      ha_enabled  = "true"
    }
  }
  
  # Create databases
  resource "azurerm_postgresql_flexible_server_database" "app" {
    name      = "oversight_prod"
    server_id = azurerm_postgresql_flexible_server.main.id
    charset   = "UTF8"
    collation = "en_US.utf8"
  }
  
  # Configure server parameters
  resource "azurerm_postgresql_flexible_server_configuration" "configs" {
    for_each = {
      shared_preload_libraries     = "pg_stat_statements,pgaudit"
      log_statement                = "all"
      log_connections             = "on"
      log_disconnections          = "on"
      log_duration               = "on"
      log_min_duration_statement = "1000"  # Log queries > 1s
      max_connections           = "200"
      shared_buffers           = "16384"    # 16GB
      effective_cache_size     = "49152"    # 48GB
      maintenance_work_mem     = "2097152"  # 2GB
      work_mem                = "16384"     # 16MB
      autovacuum              = "on"
      track_activities        = "on"
      track_counts           = "on"
    }
    
    name      = each.key
    server_id = azurerm_postgresql_flexible_server.main.id
    value     = each.value
  }
  ```
- [ ] Configure firewall rules
- [ ] Setup Azure AD authentication
- [ ] Enable threat detection

### Task 3: Configure Private Endpoint (AC: 5)
- [ ] Create private endpoint
  ```hcl
  resource "azurerm_private_endpoint" "postgresql" {
    name                = "pe-postgresql"
    location            = var.location
    resource_group_name = "rg-oversight-prod-saas-eastus"
    subnet_id           = azurerm_subnet.saas_db.id
    
    private_service_connection {
      name                           = "psc-postgresql"
      private_connection_resource_id = azurerm_postgresql_flexible_server.main.id
      subresource_names             = ["postgresqlServer"]
      is_manual_connection          = false
    }
    
    private_dns_zone_group {
      name                 = "pdz-group-psql"
      private_dns_zone_ids = [azurerm_private_dns_zone.postgresql.id]
    }
  }
  
  resource "azurerm_private_dns_zone" "postgresql" {
    name                = "privatelink.postgres.database.azure.com"
    resource_group_name = "rg-oversight-prod-saas-eastus"
  }
  
  resource "azurerm_private_dns_zone_virtual_network_link" "postgresql" {
    name                  = "pdz-link-postgresql"
    resource_group_name   = "rg-oversight-prod-saas-eastus"
    private_dns_zone_name = azurerm_private_dns_zone.postgresql.name
    virtual_network_id    = azurerm_virtual_network.main.id
  }
  ```
- [ ] Disable public access
- [ ] Test private connectivity
- [ ] Configure DNS resolution

### Task 4: Setup Connection Pooling (AC: 6)
- [ ] Configure PgBouncer
  ```hcl
  resource "azurerm_container_instance" "pgbouncer" {
    name                = "aci-pgbouncer"
    location            = var.location
    resource_group_name = "rg-oversight-prod-saas-eastus"
    ip_address_type     = "Private"
    subnet_id          = azurerm_subnet.saas_db.id
    os_type            = "Linux"
    
    container {
      name   = "pgbouncer"
      image  = "edoburu/pgbouncer:latest"
      cpu    = "1"
      memory = "2"
      
      ports {
        port     = 5432
        protocol = "TCP"
      }
      
      environment_variables = {
        DATABASES_HOST     = azurerm_postgresql_flexible_server.main.fqdn
        DATABASES_PORT     = "5432"
        DATABASES_DBNAME   = "oversight_prod"
        DATABASES_USER     = azurerm_postgresql_flexible_server.main.administrator_login
        POOL_MODE         = "transaction"
        MAX_CLIENT_CONN   = "1000"
        DEFAULT_POOL_SIZE = "25"
        MIN_POOL_SIZE     = "5"
        RESERVE_POOL_SIZE = "5"
      }
      
      secure_environment_variables = {
        DATABASES_PASSWORD = azurerm_key_vault_secret.db_admin_password.value
      }
    }
  }
  ```
- [ ] Configure application connection
  ```javascript
  // config/database.js
  const { Pool } = require('pg');
  const secretManager = require('./secrets');
  
  class DatabaseConnection {
    constructor() {
      this.pools = {};
      this.config = null;
    }
    
    async initialize() {
      this.config = await secretManager.getDatabaseConfig();
      
      // Main pool through PgBouncer
      this.pools.main = new Pool({
        host: process.env.PGBOUNCER_HOST || '10.20.3.10',
        port: 5432,
        database: this.config.database,
        user: this.config.user,
        password: this.config.password,
        max: 20,
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000,
        statement_timeout: 30000,
        query_timeout: 30000
      });
      
      // Direct connection pool for long queries
      this.pools.direct = new Pool({
        host: this.config.host,
        port: 5432,
        database: this.config.database,
        user: this.config.user,
        password: this.config.password,
        ssl: {
          rejectUnauthorized: true,
          ca: await this.getCertificate()
        },
        max: 5,
        idleTimeoutMillis: 60000
      });
      
      // Event handlers
      this.pools.main.on('error', this.handlePoolError.bind(this));
      this.pools.direct.on('error', this.handlePoolError.bind(this));
    }
    
    async query(text, params, useDirectPool = false) {
      const pool = useDirectPool ? this.pools.direct : this.pools.main;
      const start = Date.now();
      
      try {
        const result = await pool.query(text, params);
        const duration = Date.now() - start;
        
        // Log slow queries
        if (duration > 1000) {
          console.warn('Slow query:', { text, duration });
        }
        
        return result;
      } catch (error) {
        console.error('Database query error:', error);
        throw error;
      }
    }
    
    async transaction(callback) {
      const client = await this.pools.main.connect();
      
      try {
        await client.query('BEGIN');
        const result = await callback(client);
        await client.query('COMMIT');
        return result;
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
    }
  }
  
  module.exports = new DatabaseConnection();
  ```
- [ ] Test connection pooling
- [ ] Monitor pool metrics

### Task 5: Setup Automated Backups (AC: 4)
- [ ] Configure backup policy
  ```hcl
  # Backup configuration is included in server resource
  # Additional backup to storage account
  
  resource "azurerm_postgresql_flexible_server_backup" "daily" {
    name                = "backup-daily"
    server_id           = azurerm_postgresql_flexible_server.main.id
    backup_retention_days = 30
    
    storage_account_id = azurerm_storage_account.backup.id
    container_name     = "postgresql-backups"
  }
  ```
- [ ] Create backup verification script
  ```bash
  #!/bin/bash
  # verify-backup.sh
  
  SERVER_NAME="psql-oversight-prod"
  RG_NAME="rg-oversight-prod-saas-eastus"
  
  # List available backups
  az postgres flexible-server backup list \
    --server-name $SERVER_NAME \
    --resource-group $RG_NAME
  
  # Test restore to verify backup
  BACKUP_NAME=$(az postgres flexible-server backup list \
    --server-name $SERVER_NAME \
    --resource-group $RG_NAME \
    --query "[0].name" -o tsv)
  
  # Create test restore
  az postgres flexible-server restore \
    --source-server $SERVER_NAME \
    --name "${SERVER_NAME}-restore-test" \
    --resource-group $RG_NAME \
    --backup-name $BACKUP_NAME \
    --location eastus
  
  # Verify and cleanup
  echo "Backup verification complete"
  ```
- [ ] Setup backup monitoring
- [ ] Document restore procedures

### Task 6: Create Read Replicas (AC: 7)
- [ ] Deploy read replica
  ```hcl
  resource "azurerm_postgresql_flexible_server" "replica" {
    name                = "psql-oversight-prod-replica"
    location            = "westus"  # Different region for DR
    resource_group_name = "rg-oversight-prod-saas-westus"
    
    create_mode = "Replica"
    source_server_id = azurerm_postgresql_flexible_server.main.id
    
    sku_name   = "GP_Standard_D2s_v3"
    version    = "14"
    
    tags = {
      environment = "production"
      component   = "database-replica"
      purpose     = "read-only"
    }
  }
  ```
- [ ] Configure read-only routing
  ```javascript
  // config/database-replica.js
  class ReadOnlyDatabase {
    constructor() {
      this.replicaPools = [];
    }
    
    async initialize() {
      const replicas = [
        { host: 'psql-oversight-prod-replica.postgres.database.azure.com', region: 'westus' }
      ];
      
      for (const replica of replicas) {
        const pool = new Pool({
          host: replica.host,
          port: 5432,
          database: 'oversight_prod',
          user: await this.getReadOnlyUser(),
          password: await this.getReadOnlyPassword(),
          ssl: { rejectUnauthorized: true },
          max: 10,
          statement_timeout: 60000  // 60s for reporting queries
        });
        
        this.replicaPools.push({ pool, region: replica.region });
      }
    }
    
    async query(text, params) {
      // Route to nearest replica
      const pool = this.selectReplica();
      return await pool.query(text, params);
    }
    
    selectReplica() {
      // Simple round-robin, could be enhanced with latency-based routing
      const replica = this.replicaPools[this.currentIndex % this.replicaPools.length];
      this.currentIndex++;
      return replica.pool;
    }
  }
  ```
- [ ] Test replica lag
- [ ] Setup failover procedures

### Task 7: Configure Monitoring (AC: 8)
- [ ] Enable query performance insights
  ```hcl
  resource "azurerm_monitor_diagnostic_setting" "postgresql" {
    name               = "diag-postgresql"
    target_resource_id = azurerm_postgresql_flexible_server.main.id
    
    log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id
    
    enabled_log {
      category = "PostgreSQLLogs"
      retention_policy {
        enabled = true
        days    = 30
      }
    }
    
    metric {
      category = "AllMetrics"
      retention_policy {
        enabled = true
        days    = 30
      }
    }
  }
  ```
- [ ] Create monitoring queries
  ```kusto
  // Slow queries
  AzureDiagnostics
  | where ResourceType == "POSTGRESQLSERVERS"
  | where Category == "PostgreSQLLogs"
  | where Message contains "duration:"
  | extend duration = extract("duration: ([0-9.]+)", 1, Message)
  | where todouble(duration) > 1000
  | project TimeGenerated, duration, Message
  | order by todouble(duration) desc
  
  // Connection stats
  AzureMetrics
  | where ResourceType == "POSTGRESQLSERVERS"
  | where MetricName in ("active_connections", "failed_connections")
  | summarize avg(Average), max(Maximum) by MetricName, bin(TimeGenerated, 5m)
  | render timechart
  ```
- [ ] Setup performance alerts
- [ ] Create dashboard

### Task 8: Implement Security Hardening (AC: 1, 2)
- [ ] Configure advanced threat protection
- [ ] Setup audit logging
- [ ] Implement row-level security
- [ ] Test security configuration

---

## Dev Notes

### Connection Strings
```
Primary: psql-oversight-prod.postgres.database.azure.com
Replica: psql-oversight-prod-replica.postgres.database.azure.com
PgBouncer: 10.20.3.10:5432
Private Endpoint: 10.20.3.4
```

### Performance Tuning
```sql
-- Create indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_projects_org ON projects(organization_id);
CREATE INDEX idx_audit_timestamp ON audit_logs(created_at);

-- Partitioning for large tables
CREATE TABLE audit_logs_2025 PARTITION OF audit_logs
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

### Testing Standards
- Test location: `/tests/production/database/`
- Test connection through private endpoint
- Verify backup/restore works
- Test failover scenarios
- Monitor query performance

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_