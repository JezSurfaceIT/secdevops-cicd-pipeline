# Story 5.2: Configure Multi-Region Deployment

**Epic:** 5 - CBE Distribution  
**Story Number:** 5.2  
**Title:** Setup Global Application Distribution  
**Status:** READY  
**Points:** 5  
**Component:** 532 (Multi-Region)  

---

## Story

**As a** System Architect,  
**I want** applications deployed across multiple regions,  
**so that** we achieve low latency globally and maintain service during regional outages.

---

## Acceptance Criteria

1. Applications deployed in 3+ Azure regions
2. Database replication configured across regions
3. Traffic Manager for global load balancing
4. Automated failover with < 60 second RTO
5. Data consistency maintained across regions
6. Region-specific compliance requirements met
7. Cost optimization for cross-region traffic
8. Disaster recovery procedures documented

---

## Tasks / Subtasks

### Task 1: Write Multi-Region Tests (TDD) (AC: 1, 3, 4)
- [ ] Create `distribution/multi_region_test.go`
  - [ ] Test multi-region deployment
  - [ ] Test traffic routing
  - [ ] Test failover scenarios
  - [ ] Test data consistency
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy Regional Infrastructure (AC: 1)
- [ ] Create regional resource groups
  ```hcl
  # regions.tf
  variable "regions" {
    default = {
      primary = {
        location = "eastus"
        short    = "eus"
        priority = 1
      }
      secondary = {
        location = "westeurope"
        short    = "weu"
        priority = 2
      }
      tertiary = {
        location = "southeastasia"
        short    = "sea"
        priority = 3
      }
    }
  }
  
  resource "azurerm_resource_group" "regions" {
    for_each = var.regions
    
    name     = "rg-oversight-${each.value.short}-prod"
    location = each.value.location
    
    tags = {
      environment = "production"
      region      = each.key
      priority    = each.value.priority
    }
  }
  
  # Deploy App Service in each region
  resource "azurerm_app_service_plan" "regional" {
    for_each = var.regions
    
    name                = "asp-oversight-${each.value.short}"
    location            = azurerm_resource_group.regions[each.key].location
    resource_group_name = azurerm_resource_group.regions[each.key].name
    
    sku {
      tier = "PremiumV3"
      size = "P1v3"
    }
    
    zone_redundant = true
    
    tags = {
      environment = "production"
      region      = each.key
    }
  }
  
  resource "azurerm_app_service" "regional" {
    for_each = var.regions
    
    name                = "app-oversight-${each.value.short}"
    location            = azurerm_resource_group.regions[each.key].location
    resource_group_name = azurerm_resource_group.regions[each.key].name
    app_service_plan_id = azurerm_app_service_plan.regional[each.key].id
    
    site_config {
      always_on                 = true
      ftps_state               = "Disabled"
      http2_enabled            = true
      min_tls_version          = "1.2"
      health_check_path        = "/health"
      use_32_bit_worker_process = false
      
      cors {
        allowed_origins = ["https://oversight.com"]
      }
    }
    
    app_settings = {
      "REGION"                     = each.key
      "REGION_LOCATION"           = each.value.location
      "DATABASE_CONNECTION_STRING" = azurerm_key_vault_secret.db_connection[each.key].value
      "REDIS_CONNECTION_STRING"   = azurerm_key_vault_secret.redis_connection[each.key].value
      "PRIMARY_REGION"            = var.regions.primary.location
    }
    
    identity {
      type = "SystemAssigned"
    }
  }
  ```
- [ ] Deploy regional databases
  ```hcl
  # Regional PostgreSQL with read replicas
  resource "azurerm_postgresql_flexible_server" "regional" {
    for_each = var.regions
    
    name                = "psql-oversight-${each.value.short}"
    location            = azurerm_resource_group.regions[each.key].location
    resource_group_name = azurerm_resource_group.regions[each.key].name
    
    sku_name   = each.key == "primary" ? "GP_Standard_D4s_v3" : "GP_Standard_D2s_v3"
    version    = "14"
    storage_mb = each.key == "primary" ? 131072 : 65536
    
    high_availability {
      mode                      = "ZoneRedundant"
      standby_availability_zone = "2"
    }
    
    # Create replicas for non-primary regions
    dynamic "create_mode" {
      for_each = each.key != "primary" ? [1] : []
      content {
        create_mode       = "Replica"
        source_server_id = azurerm_postgresql_flexible_server.regional["primary"].id
      }
    }
    
    backup_retention_days        = 30
    geo_redundant_backup_enabled = true
    
    zone = "1"
  }
  ```
- [ ] Setup regional storage
- [ ] Configure regional networking

### Task 3: Configure Traffic Manager (AC: 3, 4)
- [ ] Setup Traffic Manager profile
  ```hcl
  resource "azurerm_traffic_manager_profile" "global" {
    name                   = "tm-oversight-global"
    resource_group_name    = azurerm_resource_group.global.name
    traffic_routing_method = "Performance"
    
    dns_config {
      relative_name = "oversight-global"
      ttl          = 30
    }
    
    monitor_config {
      protocol                     = "HTTPS"
      port                        = 443
      path                        = "/health"
      interval_in_seconds         = 30
      timeout_in_seconds          = 10
      tolerated_number_of_failures = 2
      
      custom_header {
        name  = "X-Health-Check"
        value = "TrafficManager"
      }
      
      expected_status_code_ranges = ["200-202", "301-302"]
    }
    
    tags = {
      environment = "production"
      component   = "traffic-manager"
    }
  }
  
  resource "azurerm_traffic_manager_endpoint" "regional" {
    for_each = var.regions
    
    name                = "endpoint-${each.value.short}"
    resource_group_name = azurerm_resource_group.global.name
    profile_name        = azurerm_traffic_manager_profile.global.name
    type               = "azureEndpoints"
    target_resource_id = azurerm_app_service.regional[each.key].id
    
    weight   = 100 / length(var.regions)
    priority = each.value.priority
    
    geo_mapping = local.region_geo_mapping[each.key]
    
    custom_header {
      name  = "X-Region"
      value = each.key
    }
  }
  
  # Failover profile for critical services
  resource "azurerm_traffic_manager_profile" "failover" {
    name                   = "tm-oversight-failover"
    resource_group_name    = azurerm_resource_group.global.name
    traffic_routing_method = "Priority"
    
    dns_config {
      relative_name = "oversight-failover"
      ttl          = 10  # Low TTL for fast failover
    }
    
    monitor_config {
      protocol                     = "HTTPS"
      port                        = 443
      path                        = "/health/critical"
      interval_in_seconds         = 10
      timeout_in_seconds          = 5
      tolerated_number_of_failures = 1
    }
  }
  ```
- [ ] Configure routing methods
  ```javascript
  // config/traffic-routing.js
  class TrafficRouter {
    constructor() {
      this.routingPolicies = {
        performance: {
          method: 'latency-based',
          healthCheck: '/health',
          ttl: 30
        },
        geographic: {
          method: 'geo-proximity',
          mappings: {
            'US': 'eastus',
            'EU': 'westeurope',
            'ASIA': 'southeastasia'
          }
        },
        weighted: {
          method: 'weighted-round-robin',
          weights: {
            'primary': 50,
            'secondary': 30,
            'tertiary': 20
          }
        },
        failover: {
          method: 'priority',
          priorities: {
            'primary': 1,
            'secondary': 2,
            'tertiary': 3
          },
          healthCheckInterval: 10
        }
      };
    }
    
    async routeRequest(request) {
      const clientLocation = await this.getClientLocation(request.ip);
      const healthyEndpoints = await this.getHealthyEndpoints();
      
      // Select routing policy based on service
      const policy = this.selectPolicy(request.service);
      
      switch (policy.method) {
        case 'latency-based':
          return this.routeByLatency(clientLocation, healthyEndpoints);
        
        case 'geo-proximity':
          return this.routeByGeography(clientLocation, healthyEndpoints);
        
        case 'weighted-round-robin':
          return this.routeByWeight(healthyEndpoints);
        
        case 'priority':
          return this.routeByPriority(healthyEndpoints);
        
        default:
          return healthyEndpoints[0];
      }
    }
    
    async routeByLatency(clientLocation, endpoints) {
      const latencies = await Promise.all(
        endpoints.map(async endpoint => ({
          endpoint,
          latency: await this.measureLatency(clientLocation, endpoint.region)
        }))
      );
      
      latencies.sort((a, b) => a.latency - b.latency);
      return latencies[0].endpoint;
    }
    
    async getHealthyEndpoints() {
      const endpoints = await this.getAllEndpoints();
      const healthChecks = await Promise.all(
        endpoints.map(async endpoint => ({
          endpoint,
          healthy: await this.checkHealth(endpoint)
        }))
      );
      
      return healthChecks
        .filter(hc => hc.healthy)
        .map(hc => hc.endpoint);
    }
  }
  ```
- [ ] Setup health monitoring
- [ ] Test failover scenarios

### Task 4: Implement Database Replication (AC: 2, 5)
- [ ] Configure cross-region replication
  ```javascript
  // services/database-replication.js
  class DatabaseReplication {
    constructor() {
      this.regions = {
        primary: {
          host: process.env.DB_PRIMARY_HOST,
          role: 'master',
          region: 'eastus'
        },
        secondary: {
          host: process.env.DB_SECONDARY_HOST,
          role: 'replica',
          region: 'westeurope',
          lagThreshold: 1000 // ms
        },
        tertiary: {
          host: process.env.DB_TERTIARY_HOST,
          role: 'replica',
          region: 'southeastasia',
          lagThreshold: 2000 // ms
        }
      };
    }
    
    async getConnection(operation = 'read', region = null) {
      if (operation === 'write') {
        return this.getPrimaryConnection();
      }
      
      // For reads, use nearest healthy replica
      if (region) {
        const regional = await this.getRegionalConnection(region);
        if (regional && await this.checkReplicationLag(regional) < regional.lagThreshold) {
          return regional;
        }
      }
      
      // Fallback to any healthy replica
      return await this.getHealthyReplica();
    }
    
    async getPrimaryConnection() {
      const primary = this.regions.primary;
      const connection = await this.createConnection(primary);
      
      if (!await this.checkHealth(connection)) {
        // Promote secondary if primary fails
        await this.promoteReplica('secondary');
        return await this.createConnection(this.regions.secondary);
      }
      
      return connection;
    }
    
    async promoteReplica(replicaName) {
      console.log(`Promoting ${replicaName} to primary`);
      
      const replica = this.regions[replicaName];
      
      // Azure PostgreSQL replica promotion
      await this.azureClient.servers.update(
        replica.resourceGroup,
        replica.serverName,
        {
          replicationRole: 'Primary'
        }
      );
      
      // Update application configuration
      this.regions[replicaName].role = 'master';
      this.regions.primary.role = 'replica';
      
      // Swap references
      const temp = this.regions.primary;
      this.regions.primary = this.regions[replicaName];
      this.regions[replicaName] = temp;
      
      // Notify other services
      await this.notifyFailover({
        newPrimary: replicaName,
        oldPrimary: 'primary',
        timestamp: new Date()
      });
    }
    
    async checkReplicationLag(connection) {
      const result = await connection.query(`
        SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())) * 1000 as lag_ms
      `);
      
      return result.rows[0].lag_ms;
    }
    
    async ensureConsistency(operation, data) {
      if (operation.type === 'critical') {
        // Synchronous replication for critical data
        const promises = Object.keys(this.regions).map(region =>
          this.writeToRegion(region, data)
        );
        
        await Promise.all(promises);
      } else {
        // Asynchronous replication for non-critical
        await this.writeToRegion('primary', data);
        
        // Queue for async replication
        this.replicationQueue.push({
          data,
          regions: ['secondary', 'tertiary'],
          timestamp: new Date()
        });
      }
    }
  }
  ```
- [ ] Setup conflict resolution
  ```javascript
  // services/conflict-resolver.js
  class ConflictResolver {
    async resolveConflict(conflict) {
      const strategy = this.getStrategy(conflict.type);
      
      switch (strategy) {
        case 'last-write-wins':
          return this.resolveByTimestamp(conflict);
        
        case 'region-priority':
          return this.resolveByRegionPriority(conflict);
        
        case 'merge':
          return this.mergeChanges(conflict);
        
        case 'manual':
          return await this.requestManualResolution(conflict);
        
        default:
          throw new Error(`Unknown resolution strategy: ${strategy}`);
      }
    }
    
    resolveByTimestamp(conflict) {
      // Sort by timestamp and take the latest
      const sorted = conflict.versions.sort((a, b) => 
        b.timestamp - a.timestamp
      );
      
      return sorted[0];
    }
    
    resolveByRegionPriority(conflict) {
      const priorities = { primary: 1, secondary: 2, tertiary: 3 };
      
      const sorted = conflict.versions.sort((a, b) =>
        priorities[a.region] - priorities[b.region]
      );
      
      return sorted[0];
    }
    
    async mergeChanges(conflict) {
      // Implement CRDT-based merge
      const merged = {
        id: conflict.id,
        data: {}
      };
      
      // Merge each field
      for (const field of conflict.fields) {
        if (field.type === 'counter') {
          // Sum all increments
          merged.data[field.name] = conflict.versions
            .reduce((sum, v) => sum + v.data[field.name], 0);
        } else if (field.type === 'set') {
          // Union of all sets
          merged.data[field.name] = new Set(
            conflict.versions.flatMap(v => v.data[field.name])
          );
        } else {
          // Last write wins for other types
          merged.data[field.name] = this.resolveByTimestamp({
            versions: conflict.versions.map(v => ({
              timestamp: v.timestamp,
              value: v.data[field.name]
            }))
          }).value;
        }
      }
      
      return merged;
    }
  }
  ```
- [ ] Monitor replication lag
- [ ] Test consistency scenarios

### Task 5: Implement Automated Failover (AC: 4)
- [ ] Create failover orchestrator
  ```javascript
  // services/failover-orchestrator.js
  class FailoverOrchestrator {
    constructor() {
      this.rto = 60000; // 60 seconds
      this.healthCheckInterval = 10000; // 10 seconds
      this.failoverInProgress = false;
    }
    
    async monitorHealth() {
      setInterval(async () => {
        if (this.failoverInProgress) return;
        
        const healthStatus = await this.checkAllRegions();
        
        for (const region of healthStatus) {
          if (!region.healthy && region.role === 'primary') {
            await this.initiateFailover(region);
          }
        }
      }, this.healthCheckInterval);
    }
    
    async initiateFailover(failedRegion) {
      console.log(`Initiating failover from ${failedRegion.name}`);
      const startTime = Date.now();
      
      this.failoverInProgress = true;
      
      try {
        // Step 1: Verify failure (avoid false positives)
        const verified = await this.verifyFailure(failedRegion);
        if (!verified) {
          console.log('False alarm, region recovered');
          this.failoverInProgress = false;
          return;
        }
        
        // Step 2: Select new primary
        const newPrimary = await this.selectNewPrimary(failedRegion);
        
        // Step 3: Update Traffic Manager
        await this.updateTrafficManager(failedRegion, newPrimary);
        
        // Step 4: Promote database replica
        await this.promoteDatabase(newPrimary);
        
        // Step 5: Update application configuration
        await this.updateConfiguration(newPrimary);
        
        // Step 6: Warm up new primary
        await this.warmupRegion(newPrimary);
        
        // Step 7: Verify failover success
        await this.verifyFailover(newPrimary);
        
        const elapsed = Date.now() - startTime;
        console.log(`Failover completed in ${elapsed}ms`);
        
        if (elapsed > this.rto) {
          await this.notifyRTOExceeded(elapsed);
        }
        
        // Log failover event
        await this.logFailoverEvent({
          failedRegion: failedRegion.name,
          newPrimary: newPrimary.name,
          duration: elapsed,
          timestamp: new Date()
        });
        
      } catch (error) {
        console.error('Failover failed:', error);
        await this.handleFailoverFailure(error);
      } finally {
        this.failoverInProgress = false;
      }
    }
    
    async verifyFailure(region) {
      // Multiple checks to avoid false positives
      const checks = await Promise.all([
        this.checkEndpoint(region.healthUrl),
        this.checkDatabase(region.dbConnection),
        this.checkFromMultipleLocations(region)
      ]);
      
      const failedChecks = checks.filter(c => !c).length;
      return failedChecks >= 2; // Require 2+ failed checks
    }
    
    async selectNewPrimary(failedRegion) {
      const candidates = await this.getHealthyRegions();
      
      // Sort by priority and capacity
      candidates.sort((a, b) => {
        if (a.priority !== b.priority) {
          return a.priority - b.priority;
        }
        return b.capacity - a.capacity;
      });
      
      return candidates[0];
    }
    
    async updateTrafficManager(failedRegion, newPrimary) {
      // Disable failed endpoint
      await this.trafficManagerClient.endpoints.update(
        'global',
        'tm-oversight-global',
        `endpoint-${failedRegion.short}`,
        {
          targetResourceId: failedRegion.resourceId,
          endpointStatus: 'Disabled'
        }
      );
      
      // Update priority for new primary
      await this.trafficManagerClient.endpoints.update(
        'global',
        'tm-oversight-global',
        `endpoint-${newPrimary.short}`,
        {
          priority: 1
        }
      );
    }
    
    async warmupRegion(region) {
      const warmupRequests = [
        '/health',
        '/api/config',
        '/api/metadata',
        '/cache/warm'
      ];
      
      await Promise.all(
        warmupRequests.map(path =>
          fetch(`https://${region.hostname}${path}`)
        )
      );
    }
  }
  ```
- [ ] Configure automatic recovery
- [ ] Setup failback procedures
- [ ] Test RTO compliance

### Task 6: Ensure Regional Compliance (AC: 6)
- [ ] Configure data residency
  ```hcl
  # Regional data residency configuration
  resource "azurerm_storage_account" "regional_compliant" {
    for_each = var.regions
    
    name                     = "st${each.value.short}oversight"
    resource_group_name      = azurerm_resource_group.regions[each.key].name
    location                = azurerm_resource_group.regions[each.key].location
    account_tier            = "Standard"
    account_replication_type = "ZRS"  # Zone-redundant within region
    
    # Restrict cross-region replication for compliance
    cross_tenant_replication_enabled = false
    
    network_rules {
      default_action = "Deny"
      bypass        = ["AzureServices"]
      
      # Only allow access from same region
      virtual_network_subnet_ids = [
        azurerm_subnet.regional[each.key].id
      ]
    }
    
    # Encryption with regional keys
    customer_managed_key {
      key_vault_key_id = azurerm_key_vault_key.regional[each.key].id
    }
    
    tags = {
      compliance = local.regional_compliance[each.key]
      data_residency = each.value.location
    }
  }
  ```
- [ ] Implement GDPR compliance
  ```javascript
  // services/gdpr-compliance.js
  class GDPRCompliance {
    constructor() {
      this.euRegions = ['westeurope', 'northeurope'];
      this.dataCategories = {
        personal: ['email', 'name', 'phone', 'address'],
        sensitive: ['health', 'financial', 'biometric'],
        anonymous: ['analytics', 'metrics']
      };
    }
    
    async processRequest(request, userData) {
      const userLocation = await this.getUserLocation(userData.ip);
      
      if (this.isEULocation(userLocation)) {
        return await this.processEURequest(request, userData);
      }
      
      return await this.processStandardRequest(request, userData);
    }
    
    async processEURequest(request, userData) {
      // Ensure data stays in EU
      const euRegion = this.selectEURegion(userData);
      
      // Check consent
      if (!await this.hasValidConsent(userData.userId)) {
        throw new Error('Valid consent required for EU users');
      }
      
      // Process with GDPR compliance
      const result = await this.processInRegion(request, euRegion, {
        encryption: 'required',
        retention: this.getRetentionPeriod(request.dataType),
        audit: true,
        minimization: true
      });
      
      // Log for compliance
      await this.logGDPRProcessing({
        userId: userData.userId,
        purpose: request.purpose,
        legalBasis: await this.getLegalBasis(request),
        dataCategories: this.categorizeData(request.data),
        region: euRegion,
        timestamp: new Date()
      });
      
      return result;
    }
    
    async handleDataRequest(type, userId) {
      switch (type) {
        case 'access':
          return await this.provideDataAccess(userId);
        
        case 'portability':
          return await this.exportUserData(userId);
        
        case 'erasure':
          return await this.deleteUserData(userId);
        
        case 'rectification':
          return await this.correctUserData(userId);
        
        default:
          throw new Error(`Unknown request type: ${type}`);
      }
    }
  }
  ```
- [ ] Setup regional encryption
- [ ] Configure audit logging

### Task 7: Optimize Cross-Region Traffic (AC: 7)
- [ ] Implement traffic optimization
  ```javascript
  // services/traffic-optimizer.js
  class TrafficOptimizer {
    constructor() {
      this.costPerGB = {
        'intra-region': 0.00,
        'inter-region-same-continent': 0.02,
        'inter-region-cross-continent': 0.08
      };
    }
    
    async optimizeRoute(source, destination, data) {
      const routes = await this.findAllRoutes(source, destination);
      
      // Calculate cost and latency for each route
      const evaluatedRoutes = await Promise.all(
        routes.map(async route => ({
          route,
          cost: this.calculateCost(route, data.size),
          latency: await this.measureLatency(route),
          bandwidth: await this.getAvailableBandwidth(route)
        }))
      );
      
      // Select optimal route based on requirements
      return this.selectOptimalRoute(evaluatedRoutes, data.priority);
    }
    
    selectOptimalRoute(routes, priority) {
      switch (priority) {
        case 'cost':
          return routes.sort((a, b) => a.cost - b.cost)[0].route;
        
        case 'performance':
          return routes.sort((a, b) => a.latency - b.latency)[0].route;
        
        case 'balanced':
        default:
          // Score based on cost and latency
          const scored = routes.map(r => ({
            ...r,
            score: (1 / r.cost) * 0.3 + (1 / r.latency) * 0.7
          }));
          
          return scored.sort((a, b) => b.score - a.score)[0].route;
      }
    }
    
    async implementCaching() {
      // Regional edge caches
      const cacheStrategy = {
        static: {
          regions: 'all',
          ttl: 86400,
          invalidation: 'on-update'
        },
        dynamic: {
          regions: ['primary', 'secondary'],
          ttl: 300,
          invalidation: 'time-based'
        },
        user: {
          regions: 'user-region',
          ttl: 3600,
          invalidation: 'on-change'
        }
      };
      
      return cacheStrategy;
    }
  }
  ```
- [ ] Setup cost monitoring
- [ ] Configure bandwidth optimization
- [ ] Implement data compression

### Task 8: Document DR Procedures (AC: 8)
- [ ] Create DR documentation
  ```markdown
  # Disaster Recovery Procedures
  
  ## Regional Failure Scenarios
  
  ### Scenario 1: Primary Region Failure
  1. Detection (0-30 seconds)
     - Traffic Manager health checks fail
     - Monitoring alerts triggered
     - Automated failover initiated
  
  2. Failover (30-60 seconds)
     - Traffic redirected to secondary region
     - Database replica promoted
     - Cache warmed in new primary
  
  3. Verification (60-90 seconds)
     - Health checks pass
     - Application functionality verified
     - User traffic flowing normally
  
  ### Scenario 2: Network Partition
  1. Identify split-brain condition
  2. Isolate affected region
  3. Route traffic to healthy regions
  4. Resolve network issues
  5. Reintegrate region with data reconciliation
  
  ### Scenario 3: Data Center Loss
  1. Immediate failover to secondary
  2. Restore from geo-redundant backups
  3. Rebuild in alternative region
  4. Gradual traffic migration back
  
  ## Recovery Procedures
  
  ### Database Recovery
  ```bash
  # Promote replica to primary
  az postgres server replica promote \
    --name psql-oversight-weu \
    --resource-group rg-oversight-weu-prod
  
  # Restore from backup
  az postgres server restore \
    --source-server psql-oversight-eus \
    --restore-point-in-time "2024-01-15T03:00:00Z" \
    --name psql-oversight-recovered
  ```
  
  ### Application Recovery
  ```bash
  # Scale up secondary region
  az appservice plan update \
    --name asp-oversight-weu \
    --resource-group rg-oversight-weu-prod \
    --sku P3v3 \
    --number-of-workers 5
  
  # Update Traffic Manager
  az network traffic-manager endpoint update \
    --name endpoint-eus \
    --profile-name tm-oversight-global \
    --resource-group rg-oversight-global \
    --endpoint-status Disabled
  ```
  
  ## RTO/RPO Targets
  - RTO: < 60 seconds
  - RPO: < 5 minutes
  - Availability: 99.99%
  ```
- [ ] Create runbooks
- [ ] Setup regular DR drills
- [ ] Document lessons learned

---

## Dev Notes

### Regional Endpoints
```
Primary (East US): https://app-oversight-eus.azurewebsites.net
Secondary (West Europe): https://app-oversight-weu.azurewebsites.net
Tertiary (Southeast Asia): https://app-oversight-sea.azurewebsites.net
Global: https://oversight.trafficmanager.net
```

### Replication Strategy
```
Database: Async replication with < 5 min RPO
Cache: Active-active with eventual consistency
Storage: Geo-redundant with RA-GRS
Files: CDN with regional origin groups
```

### Failover Priority
1. East US (Primary)
2. West Europe (Secondary)
3. Southeast Asia (Tertiary)

### Cost Optimization
- Use reserved instances for baseline capacity
- Auto-scale for peak traffic
- Regional caching to reduce cross-region transfers
- Compress data for replication

### Testing Standards
- Test location: `/tests/distribution/multi-region/`
- Test failover scenarios monthly
- Verify data consistency
- Monitor replication lag
- Measure actual RTO/RPO

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_