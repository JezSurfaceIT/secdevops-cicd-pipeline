# Story 2.5: Configure Docker Multi-stage Builds

**Epic:** 2 - CI/CD Pipeline Foundation  
**Story Number:** 2.5  
**Title:** Implement Secure Multi-stage Docker Builds  
**Status:** READY  
**Points:** 3  
**Component:** 306 (Docker Build)  

---

## Story

**As a** DevOps Engineer,  
**I want** optimized multi-stage Docker builds with security scanning,  
**so that** container images are minimal, secure, and production-ready.

---

## Acceptance Criteria

1. Multi-stage Dockerfiles for all applications
2. Final images use distroless or alpine base
3. No build tools or source code in final images
4. Images scanned for vulnerabilities during build
5. Layer caching optimized for faster builds
6. Images signed with Notary/Cosign
7. SBOM (Software Bill of Materials) generated
8. Image size reduced by at least 50%

---

## Tasks / Subtasks

### Task 1: Write Build Tests (TDD) (AC: 2, 3, 8)
- [ ] Create `docker/build_test.go`
  - [ ] Test image size is under threshold
  - [ ] Test no dev dependencies in final image
  - [ ] Test required binaries exist
  - [ ] Test security scan passes
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Create Multi-stage Dockerfile Templates (AC: 1, 2)
- [ ] Node.js application template
  ```dockerfile
  # Build stage
  FROM node:18-alpine AS builder
  WORKDIR /build
  
  # Install dependencies separately for caching
  COPY package*.json ./
  RUN npm ci --only=production
  
  # Copy source and build
  COPY . .
  RUN npm run build
  
  # Production stage
  FROM gcr.io/distroless/nodejs18-debian11
  WORKDIR /app
  
  # Copy only production artifacts
  COPY --from=builder /build/node_modules ./node_modules
  COPY --from=builder /build/dist ./dist
  COPY --from=builder /build/package.json ./
  
  USER 1000
  EXPOSE 3000
  CMD ["dist/index.js"]
  ```

- [ ] Go application template
  ```dockerfile
  # Build stage
  FROM golang:1.21-alpine AS builder
  WORKDIR /build
  
  # Install certificates for HTTPS
  RUN apk add --no-cache ca-certificates git
  
  # Copy go mod files for caching
  COPY go.mod go.sum ./
  RUN go mod download
  
  # Copy source and build
  COPY . .
  RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
      go build -ldflags="-w -s" -o app
  
  # Final stage
  FROM scratch
  COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
  COPY --from=builder /build/app /app
  
  USER 1000:1000
  ENTRYPOINT ["/app"]
  ```

- [ ] Python application template
- [ ] Java application template

### Task 3: Optimize Build Caching (AC: 5)
- [ ] Implement layer caching strategy
  ```groovy
  stage('Docker Build') {
    steps {
      script {
        docker.withRegistry('https://acrsecdevopsdev.azurecr.io', 'acr-credentials') {
          def app = docker.build("${IMAGE_NAME}:${BUILD_NUMBER}", 
            "--cache-from ${IMAGE_NAME}:latest " +
            "--build-arg BUILDKIT_INLINE_CACHE=1 " +
            "--target production " +
            ".")
          
          // Tag and push
          app.push('latest')
          app.push("${BUILD_NUMBER}")
        }
      }
    }
  }
  ```
- [ ] Configure BuildKit for parallel builds
  ```bash
  export DOCKER_BUILDKIT=1
  export COMPOSE_DOCKER_CLI_BUILD=1
  ```
- [ ] Setup distributed build cache
- [ ] Implement cache warming

### Task 4: Integrate Security Scanning (AC: 4)
- [ ] Add vulnerability scanning to build
  ```groovy
  stage('Scan Image') {
    steps {
      script {
        // Scan with Trivy
        sh """
          trivy image \
            --severity HIGH,CRITICAL \
            --exit-code 1 \
            ${IMAGE_NAME}:${BUILD_NUMBER}
        """
        
        // Scan with Snyk
        sh """
          snyk container test \
            --severity-threshold=high \
            ${IMAGE_NAME}:${BUILD_NUMBER}
        """
      }
    }
  }
  ```
- [ ] Configure scan policies
- [ ] Setup vulnerability allowlisting
- [ ] Create remediation workflow

### Task 5: Implement Image Signing (AC: 6)
- [ ] Setup Cosign for image signing
  ```bash
  # Generate key pair
  cosign generate-key-pair --kms azurekms://kv-oversight.vault.azure.net/keys/image-signing
  
  # Sign image
  cosign sign --key cosign.key ${IMAGE_NAME}:${BUILD_NUMBER}
  ```
- [ ] Configure signature verification
  ```yaml
  # admission-policy.yaml
  apiVersion: policy.sigstore.dev/v1beta1
  kind: ClusterImagePolicy
  metadata:
    name: image-policy
  spec:
    images:
    - glob: "acrsecdevopsdev.azurecr.io/*"
    authorities:
    - key:
        data: |
          -----BEGIN PUBLIC KEY-----
          ${COSIGN_PUBLIC_KEY}
          -----END PUBLIC KEY-----
  ```
- [ ] Setup key management
- [ ] Document verification process

### Task 6: Generate SBOM (AC: 7)
- [ ] Install and configure Syft
  ```bash
  curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
  ```
- [ ] Generate SBOM during build
  ```groovy
  stage('Generate SBOM') {
    steps {
      sh """
        syft ${IMAGE_NAME}:${BUILD_NUMBER} \
          -o spdx-json \
          > sbom-${BUILD_NUMBER}.json
        
        # Attach SBOM to image
        cosign attach sbom \
          --sbom sbom-${BUILD_NUMBER}.json \
          ${IMAGE_NAME}:${BUILD_NUMBER}
      """
      
      archiveArtifacts artifacts: 'sbom-*.json'
    }
  }
  ```
- [ ] Configure SBOM validation
- [ ] Setup license scanning

### Task 7: Optimize Image Size (AC: 8)
- [ ] Analyze current image sizes
  ```bash
  docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
  ```
- [ ] Implement size reduction techniques
  ```dockerfile
  # Minimize layers
  RUN apt-get update && \
      apt-get install -y --no-install-recommends \
        package1 \
        package2 && \
      rm -rf /var/lib/apt/lists/*
  
  # Use specific versions
  FROM node:18.17.1-alpine3.18
  
  # Remove unnecessary files
  RUN find /usr/src/app -name "*.map" -delete && \
      find /usr/src/app -name "*.ts" -delete && \
      rm -rf /usr/src/app/tests
  ```
- [ ] Setup size monitoring
- [ ] Create size budget alerts

---

## Dev Notes

### BuildKit Configuration
```yaml
# buildkitd.toml
[worker.oci]
  enabled = true
  platforms = ["linux/amd64", "linux/arm64"]
  
[registry."acrsecdevopsdev.azurecr.io"]
  mirrors = ["acrsecdevopsdev.azurecr.io"]
  
[cache]
  type = "azblob"
  [cache.azblob]
    account_url = "https://buildcache.blob.core.windows.net"
    secret_access_key = "${STORAGE_KEY}"
    container = "buildkit-cache"
```

### Docker Build Best Practices
```dockerfile
# Security scanning labels
LABEL security.scan="required"
LABEL security.scanner="trivy,snyk"

# Metadata labels
LABEL org.opencontainers.image.created="${BUILD_DATE}"
LABEL org.opencontainers.image.revision="${GIT_COMMIT}"
LABEL org.opencontainers.image.version="${VERSION}"

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
```

### Jenkins Pipeline for Docker Builds
```groovy
pipeline {
  agent any
  
  environment {
    DOCKER_BUILDKIT = '1'
    REGISTRY = 'acrsecdevopsdev.azurecr.io'
    IMAGE_NAME = "${REGISTRY}/oversight-app"
  }
  
  stages {
    stage('Build') {
      steps {
        script {
          docker.build(
            "${IMAGE_NAME}:${BUILD_NUMBER}",
            "--cache-from ${IMAGE_NAME}:latest " +
            "--build-arg VERSION=${BUILD_NUMBER} " +
            "--build-arg GIT_COMMIT=${GIT_COMMIT} " +
            "--target production ."
          )
        }
      }
    }
    
    stage('Scan') {
      parallel {
        stage('Trivy') {
          steps {
            sh "trivy image ${IMAGE_NAME}:${BUILD_NUMBER}"
          }
        }
        stage('Snyk') {
          steps {
            sh "snyk container test ${IMAGE_NAME}:${BUILD_NUMBER}"
          }
        }
      }
    }
    
    stage('Sign & Push') {
      steps {
        script {
          sh "cosign sign --key cosign.key ${IMAGE_NAME}:${BUILD_NUMBER}"
          docker.withRegistry("https://${REGISTRY}", 'acr-credentials') {
            docker.image("${IMAGE_NAME}:${BUILD_NUMBER}").push()
            docker.image("${IMAGE_NAME}:${BUILD_NUMBER}").push('latest')
          }
        }
      }
    }
  }
}
```

### Image Size Comparison
```bash
#!/bin/bash
# compare-image-sizes.sh

echo "Image Size Analysis"
echo "==================="

# Before optimization
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "BEFORE|node|python"

# After optimization
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "AFTER|distroless|alpine"

# Calculate savings
BEFORE=$(docker images --format "{{.Size}}" app:before | sed 's/MB//' | sed 's/GB/*1024/')
AFTER=$(docker images --format "{{.Size}}" app:after | sed 's/MB//' | sed 's/GB/*1024/')
SAVINGS=$(echo "scale=2; ($BEFORE - $AFTER) / $BEFORE * 100" | bc)

echo "Size reduction: ${SAVINGS}%"
```

### Testing Standards
- Test location: `/tests/docker/`
- Validate multi-stage builds work
- Test final image has no build tools
- Verify image signing works
- Check SBOM generation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_