# Story 3.5: Implement Test Feedback Loop

**Epic:** 3 - Test Environment & Automation  
**Story Number:** 3.5  
**Title:** Configure Automatic Issue Creation from Test Failures  
**Status:** READY  
**Points:** 5  
**Components:** 531-534 (Feedback Systems)  

---

## Story

**As a** Development Team Lead,  
**I want** test failures to automatically create categorized tickets,  
**so that** issues are tracked and resolved systematically without manual intervention.

---

## Acceptance Criteria

1. Test Result Analyzer (531) categorizes failures
2. App bugs create GitHub issues (532)
3. Environment issues create infrastructure tickets (533)
4. Test debt items tracked separately (534)
5. Duplicate detection prevents ticket spam
6. Priority assigned based on failure impact
7. Tickets include full diagnostic information
8. Dashboard shows feedback loop metrics

---

## Tasks / Subtasks

### Task 1: Write Feedback Tests (TDD) (AC: 1, 2, 3, 4)
- [ ] Create `feedback/analyzer_test.go`
  - [ ] Test failure categorization works
  - [ ] Test GitHub issue creation
  - [ ] Test Azure DevOps ticket creation
  - [ ] Test duplicate detection
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Build Test Result Analyzer (AC: 1)
- [ ] Create analyzer service
  ```javascript
  // test-analyzer/analyzer.js
  class TestResultAnalyzer {
    constructor() {
      this.categories = {
        APP_BUG: 'Application Bug',
        ENV_ISSUE: 'Environment Issue',
        TEST_DEBT: 'Test Debt',
        DATA_ISSUE: 'Test Data Issue',
        FLAKY_TEST: 'Flaky Test'
      };
      
      this.patterns = [
        {
          pattern: /Connection refused|ECONNREFUSED/,
          category: 'ENV_ISSUE',
          subcategory: 'Network'
        },
        {
          pattern: /Cannot find module|Module not found/,
          category: 'ENV_ISSUE',
          subcategory: 'Dependencies'
        },
        {
          pattern: /Expected .* to equal|toBe|toEqual/,
          category: 'APP_BUG',
          subcategory: 'Logic Error'
        },
        {
          pattern: /Timeout|exceeded .* timeout/,
          category: 'TEST_DEBT',
          subcategory: 'Slow Test'
        }
      ];
    }
    
    analyzeFailure(testResult) {
      const analysis = {
        testName: testResult.name,
        testFile: testResult.file,
        failure: testResult.error,
        category: null,
        subcategory: null,
        priority: 'medium',
        confidence: 0
      };
      
      // Pattern matching
      for (const rule of this.patterns) {
        if (rule.pattern.test(testResult.error)) {
          analysis.category = rule.category;
          analysis.subcategory = rule.subcategory;
          analysis.confidence = 0.8;
          break;
        }
      }
      
      // ML-based classification if no pattern match
      if (!analysis.category) {
        const mlResult = this.classifyWithML(testResult);
        analysis.category = mlResult.category;
        analysis.confidence = mlResult.confidence;
      }
      
      // Determine priority
      analysis.priority = this.calculatePriority(analysis);
      
      return analysis;
    }
    
    calculatePriority(analysis) {
      if (analysis.category === 'APP_BUG' && analysis.testName.includes('critical')) {
        return 'high';
      }
      if (analysis.category === 'ENV_ISSUE') {
        return 'high';
      }
      if (analysis.category === 'TEST_DEBT' && analysis.confidence < 0.5) {
        return 'low';
      }
      return 'medium';
    }
    
    async classifyWithML(testResult) {
      // Simple TF-IDF based classification
      const features = this.extractFeatures(testResult.error);
      const prediction = await this.model.predict(features);
      
      return {
        category: prediction.label,
        confidence: prediction.confidence
      };
    }
  }
  ```
- [ ] Train classification model
- [ ] Configure pattern rules
- [ ] Setup confidence thresholds

### Task 3: Implement GitHub Issue Creation (AC: 2)
- [ ] Configure GitHub integration
  ```javascript
  // integrations/github.js
  const { Octokit } = require('@octokit/rest');
  
  class GitHubIntegration {
    constructor(token) {
      this.octokit = new Octokit({ auth: token });
      this.owner = 'your-org';
      this.repo = 'oversight-mvp';
    }
    
    async createIssue(analysis) {
      // Check for duplicates first
      const duplicate = await this.findDuplicate(analysis);
      if (duplicate) {
        return this.updateExisting(duplicate, analysis);
      }
      
      const issue = await this.octokit.issues.create({
        owner: this.owner,
        repo: this.repo,
        title: this.generateTitle(analysis),
        body: this.generateBody(analysis),
        labels: this.generateLabels(analysis),
        assignees: this.getAssignees(analysis)
      });
      
      return issue.data;
    }
    
    generateTitle(analysis) {
      return `[${analysis.category}] Test failure: ${analysis.testName}`;
    }
    
    generateBody(analysis) {
      return `
## Test Failure Analysis

**Test:** ${analysis.testName}
**File:** ${analysis.testFile}
**Category:** ${analysis.category}
**Subcategory:** ${analysis.subcategory}
**Priority:** ${analysis.priority}
**Confidence:** ${(analysis.confidence * 100).toFixed(0)}%

### Error Details
\`\`\`
${analysis.failure}
\`\`\`

### Environment
- **Build:** ${process.env.BUILD_NUMBER}
- **Branch:** ${process.env.BRANCH_NAME}
- **Commit:** ${process.env.GIT_COMMIT}
- **Timestamp:** ${new Date().toISOString()}

### Diagnostic Information
- **Logs:** [View Logs](${process.env.BUILD_URL}/console)
- **Test Report:** [View Report](${process.env.BUILD_URL}/testReport)
- **Recording:** [View Recording](${analysis.recordingUrl})

### Suggested Actions
${this.generateSuggestions(analysis)}

---
*This issue was automatically created by the Test Feedback System*
      `;
    }
    
    generateLabels(analysis) {
      const labels = ['automated', 'test-failure'];
      
      labels.push(analysis.category.toLowerCase().replace('_', '-'));
      labels.push(`priority-${analysis.priority}`);
      
      if (analysis.subcategory) {
        labels.push(analysis.subcategory.toLowerCase());
      }
      
      return labels;
    }
    
    async findDuplicate(analysis) {
      const issues = await this.octokit.issues.listForRepo({
        owner: this.owner,
        repo: this.repo,
        labels: analysis.category.toLowerCase().replace('_', '-'),
        state: 'open'
      });
      
      for (const issue of issues.data) {
        if (this.isSimilar(issue.title, analysis.testName)) {
          return issue;
        }
      }
      
      return null;
    }
  }
  ```
- [ ] Setup webhook for updates
- [ ] Configure auto-assignment
- [ ] Create issue templates

### Task 4: Setup Azure DevOps Integration (AC: 3, 4)
- [ ] Configure Azure DevOps tickets
  ```javascript
  // integrations/azure-devops.js
  const azdev = require('azure-devops-node-api');
  
  class AzureDevOpsIntegration {
    constructor(config) {
      this.connection = new azdev.WebApi(
        config.orgUrl,
        azdev.getPersonalAccessTokenHandler(config.token)
      );
      this.project = config.project;
    }
    
    async createWorkItem(analysis) {
      const wit = await this.connection.getWorkItemTrackingApi();
      
      const type = this.getWorkItemType(analysis.category);
      const duplicate = await this.findDuplicate(analysis);
      
      if (duplicate) {
        return this.updateExisting(duplicate, analysis);
      }
      
      const document = [
        {
          op: 'add',
          path: '/fields/System.Title',
          value: this.generateTitle(analysis)
        },
        {
          op: 'add',
          path: '/fields/System.Description',
          value: this.generateDescription(analysis)
        },
        {
          op: 'add',
          path: '/fields/Microsoft.VSTS.Common.Priority',
          value: this.mapPriority(analysis.priority)
        },
        {
          op: 'add',
          path: '/fields/System.Tags',
          value: this.generateTags(analysis)
        }
      ];
      
      const workItem = await wit.createWorkItem(
        null,
        document,
        this.project,
        type
      );
      
      // Attach diagnostics
      await this.attachDiagnostics(workItem.id, analysis);
      
      return workItem;
    }
    
    getWorkItemType(category) {
      const mapping = {
        'ENV_ISSUE': 'Issue',
        'TEST_DEBT': 'Technical Debt',
        'DATA_ISSUE': 'Task'
      };
      
      return mapping[category] || 'Bug';
    }
    
    async attachDiagnostics(workItemId, analysis) {
      // Attach logs
      if (analysis.logs) {
        await this.attachFile(workItemId, analysis.logs, 'console.log');
      }
      
      // Attach screenshot
      if (analysis.screenshot) {
        await this.attachFile(workItemId, analysis.screenshot, 'failure.png');
      }
      
      // Attach test results
      if (analysis.testResults) {
        await this.attachFile(workItemId, analysis.testResults, 'results.xml');
      }
    }
  }
  ```
- [ ] Configure work item types
- [ ] Setup area paths
- [ ] Create automation rules

### Task 5: Implement Duplicate Detection (AC: 5)
- [ ] Create similarity algorithm
  ```javascript
  // duplicate-detector.js
  class DuplicateDetector {
    constructor() {
      this.threshold = 0.85;
    }
    
    async findDuplicates(analysis, existingIssues) {
      const candidates = [];
      
      for (const issue of existingIssues) {
        const similarity = this.calculateSimilarity(analysis, issue);
        
        if (similarity >= this.threshold) {
          candidates.push({
            issue,
            similarity,
            confidence: this.calculateConfidence(analysis, issue)
          });
        }
      }
      
      return candidates.sort((a, b) => b.similarity - a.similarity);
    }
    
    calculateSimilarity(analysis, issue) {
      const factors = {
        testName: this.stringSimilarity(analysis.testName, issue.testName) * 0.3,
        errorMessage: this.stringSimilarity(analysis.failure, issue.error) * 0.4,
        stackTrace: this.stackTraceSimilarity(analysis.stack, issue.stack) * 0.2,
        category: analysis.category === issue.category ? 0.1 : 0
      };
      
      return Object.values(factors).reduce((sum, val) => sum + val, 0);
    }
    
    stringSimilarity(str1, str2) {
      // Levenshtein distance based similarity
      const distance = this.levenshtein(str1, str2);
      const maxLen = Math.max(str1.length, str2.length);
      return 1 - (distance / maxLen);
    }
    
    stackTraceSimilarity(stack1, stack2) {
      if (!stack1 || !stack2) return 0;
      
      const lines1 = stack1.split('\n').slice(0, 5);
      const lines2 = stack2.split('\n').slice(0, 5);
      
      let matches = 0;
      for (let i = 0; i < Math.min(lines1.length, lines2.length); i++) {
        if (this.normalizeStackLine(lines1[i]) === this.normalizeStackLine(lines2[i])) {
          matches++;
        }
      }
      
      return matches / Math.max(lines1.length, lines2.length);
    }
    
    normalizeStackLine(line) {
      // Remove line numbers and specific values
      return line.replace(/:\d+:\d+/, '')
                 .replace(/\d+/g, 'N')
                 .replace(/0x[0-9a-f]+/gi, 'ADDR');
    }
  }
  ```
- [ ] Setup caching for performance
- [ ] Configure merge strategies
- [ ] Create similarity thresholds

### Task 6: Configure Priority Assignment (AC: 6)
- [ ] Create priority matrix
  ```javascript
  // priority-calculator.js
  class PriorityCalculator {
    calculate(analysis) {
      const factors = {
        failureRate: this.getFailureRate(analysis.testName),
        businessImpact: this.getBusinessImpact(analysis.testName),
        userImpact: this.getUserImpact(analysis.category),
        frequency: this.getTestFrequency(analysis.testName),
        age: this.getTestAge(analysis.testName)
      };
      
      const score = this.calculateScore(factors);
      
      if (score >= 8) return 'critical';
      if (score >= 6) return 'high';
      if (score >= 4) return 'medium';
      return 'low';
    }
    
    calculateScore(factors) {
      const weights = {
        failureRate: 0.3,
        businessImpact: 0.25,
        userImpact: 0.2,
        frequency: 0.15,
        age: 0.1
      };
      
      return Object.keys(factors).reduce((sum, key) => {
        return sum + (factors[key] * weights[key] * 10);
      }, 0);
    }
    
    getBusinessImpact(testName) {
      const critical = ['payment', 'auth', 'security', 'data'];
      const high = ['user', 'api', 'integration'];
      
      for (const term of critical) {
        if (testName.toLowerCase().includes(term)) return 1.0;
      }
      
      for (const term of high) {
        if (testName.toLowerCase().includes(term)) return 0.7;
      }
      
      return 0.3;
    }
  }
  ```
- [ ] Configure escalation rules
- [ ] Setup SLA tracking
- [ ] Create priority overrides

### Task 7: Add Diagnostic Information (AC: 7)
- [ ] Collect comprehensive diagnostics
  ```javascript
  // diagnostic-collector.js
  class DiagnosticCollector {
    async collect(testResult) {
      const diagnostics = {
        test: this.getTestInfo(testResult),
        environment: await this.getEnvironmentInfo(),
        system: await this.getSystemInfo(),
        logs: await this.getLogs(testResult),
        metrics: await this.getMetrics(testResult),
        related: await this.getRelatedInfo(testResult)
      };
      
      return diagnostics;
    }
    
    async getLogs(testResult) {
      const logs = {
        application: await this.getAppLogs(testResult.timestamp),
        system: await this.getSystemLogs(testResult.timestamp),
        test: testResult.logs
      };
      
      // Query Log Analytics
      const query = `
        ContainerInstanceLog_CL
        | where TimeGenerated between(datetime("${testResult.startTime}") .. datetime("${testResult.endTime}"))
        | where ContainerGroup_s == "aci-test-environment"
        | project TimeGenerated, Message, Level_s
        | order by TimeGenerated asc
      `;
      
      logs.container = await this.queryLogAnalytics(query);
      
      return logs;
    }
    
    async getMetrics(testResult) {
      return {
        cpu: await this.getCPUMetrics(testResult.timestamp),
        memory: await this.getMemoryMetrics(testResult.timestamp),
        network: await this.getNetworkMetrics(testResult.timestamp),
        disk: await this.getDiskMetrics(testResult.timestamp)
      };
    }
  }
  ```
- [ ] Setup log aggregation
- [ ] Configure metric collection
- [ ] Create diagnostic templates

### Task 8: Create Feedback Dashboard (AC: 8)
- [ ] Build metrics dashboard
  ```javascript
  // dashboard/feedback-metrics.js
  class FeedbackDashboard {
    async getMetrics() {
      return {
        summary: {
          totalFailures: await this.getTotalFailures(),
          ticketsCreated: await this.getTicketsCreated(),
          duplicatesDetected: await this.getDuplicatesDetected(),
          averageResolutionTime: await this.getAverageResolutionTime()
        },
        
        byCategory: {
          appBugs: await this.getByCategory('APP_BUG'),
          envIssues: await this.getByCategory('ENV_ISSUE'),
          testDebt: await this.getByCategory('TEST_DEBT')
        },
        
        trends: {
          daily: await this.getDailyTrends(),
          weekly: await this.getWeeklyTrends(),
          categoryTrends: await this.getCategoryTrends()
        },
        
        effectiveness: {
          automationRate: await this.getAutomationRate(),
          accuracyRate: await this.getAccuracyRate(),
          falsePositiveRate: await this.getFalsePositiveRate()
        }
      };
    }
  }
  ```
- [ ] Create visualizations
- [ ] Setup real-time updates
- [ ] Configure alerts

---

## Dev Notes

### Feedback Loop Architecture
```
Test Failure → Analyzer → Categorization → Issue Creation → Assignment → Resolution
     ↑                                                                        ↓
     ←────────────────────── Feedback & Learning ───────────────────────────←
```

### Category Mapping
| Category | System | Priority | Auto-Assign |
|----------|--------|----------|-------------|
| APP_BUG | GitHub | Based on impact | Dev team |
| ENV_ISSUE | Azure DevOps | High | Ops team |
| TEST_DEBT | Azure DevOps | Low | QA team |
| DATA_ISSUE | Azure DevOps | Medium | Data team |

### Testing Standards
- Test location: `/tests/feedback/`
- Mock external APIs
- Test categorization accuracy
- Verify duplicate detection
- Check ticket creation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_