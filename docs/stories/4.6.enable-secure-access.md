# Story 4.6: Enable Secure Access

**Epic:** 4 - Production SaaS Deployment  
**Story Number:** 4.6  
**Title:** Deploy Azure Bastion for Administrative Access  
**Status:** READY  
**Points:** 3  
**Component:** 721 (Azure Bastion)  

---

## Story

**As a** System Administrator,  
**I want** secure administrative access to production resources,  
**so that** we can manage systems without exposing them to the public internet.

---

## Acceptance Criteria

1. Azure Bastion deployed in dedicated subnet (10.10.1.0/24)
2. No public IPs on production VMs
3. Multi-factor authentication required
4. Session recording enabled
5. Just-in-time VM access configured
6. Privileged Identity Management (PIM) integrated
7. Audit logs for all access
8. Break-glass emergency access procedures

---

## Tasks / Subtasks

### Task 1: Write Access Tests (TDD) (AC: 1, 2, 7)
- [ ] Create `production/bastion_test.go`
  - [ ] Test Bastion deployment
  - [ ] Test no public IPs on VMs
  - [ ] Test access logging
  - [ ] Test MFA enforcement
- [ ] Run tests to confirm they fail (Red phase)

### Task 2: Deploy Azure Bastion (AC: 1, 2)
- [ ] Create Bastion infrastructure
  ```hcl
  resource "azurerm_bastion_host" "main" {
    name                = "bastion-oversight-prod"
    location            = var.location
    resource_group_name = "rg-oversight-shared-network-eastus"
    
    sku = "Standard"
    
    ip_configuration {
      name                 = "configuration"
      subnet_id            = azurerm_subnet.bastion.id
      public_ip_address_id = azurerm_public_ip.bastion.id
    }
    
    # Standard SKU features
    copy_paste_enabled     = true
    file_copy_enabled      = true
    ip_connect_enabled     = true
    shareable_link_enabled = false  # Security: Disable shareable links
    tunneling_enabled      = true
    scale_units           = 2  # For HA
    
    tags = {
      environment = "production"
      component   = "secure-access"
      compliance  = "required"
    }
  }
  
  resource "azurerm_public_ip" "bastion" {
    name                = "pip-bastion"
    location            = var.location
    resource_group_name = "rg-oversight-shared-network-eastus"
    allocation_method   = "Static"
    sku                = "Standard"
  }
  
  # Dedicated subnet for Bastion (must be named AzureBastionSubnet)
  resource "azurerm_subnet" "bastion" {
    name                 = "AzureBastionSubnet"
    resource_group_name  = "rg-oversight-shared-network-eastus"
    virtual_network_name = azurerm_virtual_network.main.name
    address_prefixes     = ["10.10.1.0/24"]
  }
  
  # NSG for Bastion subnet
  resource "azurerm_network_security_group" "bastion" {
    name                = "nsg-bastion"
    location            = var.location
    resource_group_name = "rg-oversight-shared-network-eastus"
    
    # Inbound rules
    security_rule {
      name                       = "AllowHttpsInbound"
      priority                   = 120
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "Tcp"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "Internet"
      destination_address_prefix = "*"
    }
    
    security_rule {
      name                       = "AllowGatewayManagerInbound"
      priority                   = 130
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "Tcp"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "GatewayManager"
      destination_address_prefix = "*"
    }
    
    # Outbound rules
    security_rule {
      name                       = "AllowSshRdpOutbound"
      priority                   = 100
      direction                  = "Outbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_ranges    = ["22", "3389"]
      source_address_prefix      = "*"
      destination_address_prefix = "VirtualNetwork"
    }
  }
  ```
- [ ] Remove public IPs from VMs
- [ ] Configure network routing
- [ ] Test connectivity

### Task 3: Configure Multi-Factor Authentication (AC: 3)
- [ ] Setup MFA requirement
  ```powershell
  # Configure Conditional Access Policy
  $policy = New-AzureADMSConditionalAccessPolicy -DisplayName "Bastion MFA Required" `
    -State "Enabled" `
    -Conditions @{
      ClientAppTypes = @("Browser", "MobileAppsAndDesktopClients")
      Applications = @{
        IncludeApplications = @("00000003-0000-0000-c000-000000000000")  # Azure Management
      }
      Users = @{
        IncludeGroups = @("ProductionAdmins")
      }
    } `
    -GrantControls @{
      Operator = "OR"
      BuiltInControls = @("Mfa")
    }
  ```
- [ ] Configure Azure AD integration
  ```javascript
  // auth/mfa-verification.js
  const { ConfidentialClientApplication } = require('@azure/msal-node');
  
  class MFAVerification {
    constructor() {
      this.msalClient = new ConfidentialClientApplication({
        auth: {
          clientId: process.env.AZURE_CLIENT_ID,
          authority: `https://login.microsoftonline.com/${process.env.AZURE_TENANT_ID}`,
          clientSecret: process.env.AZURE_CLIENT_SECRET
        }
      });
    }
    
    async verifyMFA(userId, sessionId) {
      try {
        // Check MFA status
        const mfaStatus = await this.checkUserMFAStatus(userId);
        
        if (!mfaStatus.isEnrolled) {
          throw new Error('User must enroll in MFA before accessing production');
        }
        
        if (!mfaStatus.recentlyVerified) {
          // Trigger MFA challenge
          return await this.triggerMFAChallenge(userId, sessionId);
        }
        
        return {
          verified: true,
          timestamp: new Date(),
          method: mfaStatus.method
        };
      } catch (error) {
        console.error('MFA verification failed:', error);
        throw error;
      }
    }
    
    async checkUserMFAStatus(userId) {
      // Query Azure AD for MFA status
      const graphClient = await this.getGraphClient();
      const user = await graphClient.api(`/users/${userId}/authentication/methods`).get();
      
      return {
        isEnrolled: user.value.length > 0,
        methods: user.value.map(m => m.type),
        recentlyVerified: this.checkRecentVerification(userId)
      };
    }
  }
  ```
- [ ] Test MFA enforcement
- [ ] Setup backup authentication

### Task 4: Enable Session Recording (AC: 4)
- [ ] Configure session recording
  ```hcl
  resource "azurerm_storage_container" "session_recordings" {
    name                  = "bastion-recordings"
    storage_account_name  = azurerm_storage_account.logs.name
    container_access_type = "private"
  }
  
  resource "azurerm_monitor_diagnostic_setting" "bastion" {
    name               = "diag-bastion"
    target_resource_id = azurerm_bastion_host.main.id
    
    log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id
    storage_account_id        = azurerm_storage_account.logs.id
    
    enabled_log {
      category = "BastionAuditLogs"
      retention_policy {
        enabled = true
        days    = 90
      }
    }
  }
  ```
- [ ] Implement session replay
  ```javascript
  // services/session-recording.js
  class SessionRecordingService {
    constructor() {
      this.storageClient = new BlobServiceClient(
        process.env.STORAGE_CONNECTION_STRING
      );
      this.container = this.storageClient.getContainerClient('bastion-recordings');
    }
    
    async startRecording(sessionId, userId, targetVm) {
      const metadata = {
        sessionId,
        userId,
        targetVm,
        startTime: new Date().toISOString(),
        ipAddress: this.getClientIp()
      };
      
      const blobName = `${sessionId}-${Date.now()}.recording`;
      const blockBlobClient = this.container.getBlockBlobClient(blobName);
      
      // Create append blob for streaming
      await blockBlobClient.create();
      await blockBlobClient.setMetadata(metadata);
      
      return {
        blobName,
        streamUrl: blockBlobClient.url
      };
    }
    
    async appendToRecording(sessionId, data) {
      const blobName = await this.getRecordingBlob(sessionId);
      const appendBlobClient = this.container.getAppendBlobClient(blobName);
      
      await appendBlobClient.appendBlock(data, data.length);
    }
    
    async stopRecording(sessionId) {
      const blobName = await this.getRecordingBlob(sessionId);
      const blobClient = this.container.getBlobClient(blobName);
      
      await blobClient.setMetadata({
        ...await blobClient.getProperties().metadata,
        endTime: new Date().toISOString(),
        status: 'completed'
      });
      
      // Generate SAS for playback
      const sasUrl = await this.generatePlaybackUrl(blobName);
      
      // Log session end
      await this.logSessionEnd(sessionId, sasUrl);
      
      return sasUrl;
    }
  }
  ```
- [ ] Setup retention policies
- [ ] Create playback interface

### Task 5: Configure Just-In-Time Access (AC: 5)
- [ ] Enable JIT VM access
  ```hcl
  resource "azurerm_security_center_subscription_pricing" "vm" {
    tier          = "Standard"
    resource_type = "VirtualMachines"
  }
  
  resource "azurerm_security_center_vm_workload_protection" "jit" {
    resource_group_name = "rg-oversight-prod-saas-eastus"
    virtual_machine_id  = azurerm_linux_virtual_machine.admin_vm.id
    
    configuration {
      type = "JIT"
      
      jit_policy {
        port {
          number   = 22
          protocol = "TCP"
          max_request_access_duration = "PT3H"  # 3 hours max
          
          allowed_source_address_prefixes = [
            "10.10.1.0/24"  # Bastion subnet only
          ]
        }
        
        port {
          number   = 3389
          protocol = "TCP"
          max_request_access_duration = "PT3H"
          
          allowed_source_address_prefixes = [
            "10.10.1.0/24"
          ]
        }
      }
    }
  }
  ```
- [ ] Create access request workflow
  ```javascript
  // services/jit-access.js
  class JITAccessService {
    async requestAccess(userId, vmId, duration, justification) {
      // Validate request
      if (!await this.validateUser(userId)) {
        throw new Error('User not authorized for JIT access');
      }
      
      if (duration > 10800) {  // 3 hours max
        throw new Error('Duration exceeds maximum allowed');
      }
      
      // Create access request
      const request = {
        requestId: uuidv4(),
        userId,
        vmId,
        duration,
        justification,
        status: 'pending',
        requestedAt: new Date()
      };
      
      // Check for auto-approval
      if (await this.canAutoApprove(userId, vmId)) {
        await this.approveAccess(request);
        request.status = 'approved';
      } else {
        // Send for manual approval
        await this.sendForApproval(request);
      }
      
      return request;
    }
    
    async approveAccess(request) {
      // Open JIT port
      const result = await this.azureClient.enableJITAccess({
        vmId: request.vmId,
        ports: [22, 3389],
        sourceIP: '10.10.1.0/24',
        duration: request.duration
      });
      
      // Set expiration timer
      setTimeout(() => {
        this.revokeAccess(request.requestId);
      }, request.duration * 1000);
      
      // Audit log
      await this.auditLog('JIT_ACCESS_GRANTED', request);
      
      return result;
    }
  }
  ```
- [ ] Setup auto-revocation
- [ ] Create approval workflow

### Task 6: Integrate Privileged Identity Management (AC: 6)
- [ ] Configure PIM roles
  ```powershell
  # Configure PIM for Production Admins
  $role = Get-AzureADMSPrivilegedRoleDefinition -ProviderId "aadRoles" `
    -Filter "DisplayName eq 'Global Administrator'"
  
  $schedule = New-AzureADMSPrivilegedRoleAssignmentSchedule `
    -ProviderId "aadRoles" `
    -RoleDefinitionId $role.Id `
    -SubjectId $userId `
    -Type "UserAdd" `
    -AssignmentState "Eligible" `
    -Schedule @{
      StartDateTime = (Get-Date)
      EndDateTime = (Get-Date).AddHours(8)
      Type = "Once"
    } `
    -Reason "Production maintenance window"
  ```
- [ ] Setup elevation workflow
- [ ] Configure approval requirements
- [ ] Test PIM activation

### Task 7: Configure Audit Logging (AC: 7)
- [ ] Setup comprehensive logging
  ```kusto
  // Bastion access audit query
  BastionAuditLogs
  | where TimeGenerated > ago(24h)
  | extend 
      User = tostring(split(UserName, "@")[0]),
      Domain = tostring(split(UserName, "@")[1]),
      Duration = datetime_diff('minute', DisconnectTime, ConnectTime)
  | project TimeGenerated, User, TargetResourceName, Protocol, Duration, ClientIpAddress
  | order by TimeGenerated desc
  
  // Suspicious access patterns
  BastionAuditLogs
  | where TimeGenerated > ago(7d)
  | summarize 
      AccessCount = count(),
      UniqueTargets = dcount(TargetResourceName),
      AvgDuration = avg(datetime_diff('minute', DisconnectTime, ConnectTime))
    by UserName, bin(TimeGenerated, 1d)
  | where AccessCount > 10 or UniqueTargets > 5
  ```
- [ ] Create audit dashboard
- [ ] Setup retention policies
- [ ] Configure compliance reports

### Task 8: Create Break-Glass Procedures (AC: 8)
- [ ] Setup emergency access
  ```hcl
  resource "azurerm_key_vault_secret" "break_glass" {
    name         = "break-glass-account"
    value        = jsonencode({
      username = "breakglass@oversight.com"
      password = random_password.break_glass.result
    })
    key_vault_id = azurerm_key_vault.main.id
    
    tags = {
      purpose = "emergency-access"
      notify  = "security-team@oversight.com"
    }
  }
  ```
- [ ] Document procedures
- [ ] Test emergency access
- [ ] Setup monitoring alerts

---

## Dev Notes

### Access URLs
```
Bastion Portal: https://portal.azure.com/#blade/BastionHosts
Connection: Via Azure Portal or Azure CLI
Session Recordings: /bastion-recordings container
Audit Logs: Log Analytics Workspace
```

### Access Procedures
```yaml
Regular Access:
1. Login to Azure Portal with MFA
2. Navigate to target VM
3. Click "Connect" > "Bastion"
4. Enter credentials
5. Session recorded automatically

JIT Access:
1. Request access via portal/API
2. Provide justification
3. Wait for approval (or auto-approve)
4. Access granted for specified duration
5. Auto-revoke after timeout

Emergency Access:
1. Retrieve break-glass credentials from Key Vault
2. Login with emergency account
3. Alert sent to security team
4. Complete incident report within 24 hours
```

### Testing Standards
- Test location: `/tests/production/access/`
- Test MFA enforcement
- Verify session recording
- Test JIT workflow
- Validate audit logging

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-22 | 1.0 | Initial story creation | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated during development_

### Completion Notes List
_To be populated during development_

### File List
_To be populated during development_

---

## QA Results
_To be populated by QA agent_