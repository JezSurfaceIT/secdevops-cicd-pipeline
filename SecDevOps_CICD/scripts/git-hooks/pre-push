#!/bin/bash

# Pre-push hook for SecDevOps CI/CD Pipeline
# This hook runs before pushing to remote repository

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

print_message "$GREEN" "=================================="
print_message "$GREEN" "Running pre-push checks..."
print_message "$GREEN" "=================================="

# Read the remote and URL
remote="$1"
url="$2"

# Track if any checks fail
FAILED=0

# Protected branches
PROTECTED_BRANCHES=(
    "refs/heads/main"
    "refs/heads/master"
    "refs/heads/develop"
    "refs/heads/production"
)

# Read stdin for pushed refs
while read local_ref local_sha remote_ref remote_sha; do
    
    # 1. Check for protected branches
    print_message "$YELLOW" "→ Checking branch protection..."
    
    for protected_branch in "${PROTECTED_BRANCHES[@]}"; do
        if [ "$remote_ref" = "$protected_branch" ]; then
            # Allow if this is a CI/CD environment
            if [ -n "$CI" ] || [ -n "$JENKINS_HOME" ] || [ -n "$GITHUB_ACTIONS" ]; then
                print_message "$YELLOW" "⚠ Pushing to protected branch $protected_branch (CI/CD environment)"
            else
                # Check if force push
                if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
                    print_message "$RED" "✗ Attempting to delete protected branch: $protected_branch"
                    FAILED=1
                elif git merge-base --is-ancestor "$remote_sha" "$local_sha" 2>/dev/null; then
                    print_message "$YELLOW" "⚠ Direct push to protected branch: $protected_branch"
                    print_message "$YELLOW" "  Consider creating a pull request instead"
                    
                    # Optional: Uncomment to enforce PR-only workflow
                    # print_message "$RED" "✗ Direct pushes to protected branches are not allowed"
                    # print_message "$RED" "  Please create a feature branch and submit a pull request"
                    # FAILED=1
                else
                    print_message "$RED" "✗ Force push to protected branch detected: $protected_branch"
                    print_message "$RED" "  Force pushes to protected branches are not allowed"
                    FAILED=1
                fi
            fi
        fi
    done
    
    # 2. Check for large files
    print_message "$YELLOW" "→ Checking for large files..."
    
    # Maximum file size in bytes (10MB for push)
    MAX_SIZE=10485760
    
    # Get list of files being pushed
    files=$(git diff --name-only "$remote_sha".."$local_sha" 2>/dev/null || git ls-tree -r "$local_sha" --name-only)
    
    large_files_found=0
    for file in $files; do
        if [ -f "$file" ]; then
            file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            if [ "$file_size" -gt "$MAX_SIZE" ]; then
                print_message "$RED" "✗ Large file detected: $file ($(($file_size / 1024 / 1024))MB)"
                print_message "$RED" "  Files larger than 10MB should not be pushed"
                print_message "$YELLOW" "  Consider using Git LFS for large files"
                FAILED=1
                large_files_found=1
            fi
        fi
    done
    
    if [ $large_files_found -eq 0 ]; then
        print_message "$GREEN" "✓ No large files detected"
    fi
    
    # 3. Check for secrets in commits being pushed
    print_message "$YELLOW" "→ Scanning commits for secrets..."
    
    # Patterns to check for potential secrets
    SECRET_PATTERNS=(
        "AWS[_-]?SECRET"
        "AWS[_-]?ACCESS[_-]?KEY"
        "API[_-]?KEY"
        "PRIVATE[_-]?KEY"
        "-----BEGIN.*PRIVATE KEY-----"
        "password\s*=\s*['\"]"
        "token\s*=\s*['\"]"
        "Bearer\s+"
        "client[_-]?secret"
    )
    
    secrets_found=0
    commits=$(git rev-list "$remote_sha".."$local_sha" 2>/dev/null || echo "$local_sha")
    
    for commit in $commits; do
        for pattern in "${SECRET_PATTERNS[@]}"; do
            if git show "$commit" | grep -iE "$pattern" > /dev/null 2>&1; then
                print_message "$RED" "✗ Potential secret detected in commit $commit"
                print_message "$RED" "  Pattern matched: $pattern"
                print_message "$RED" "  Please remove secrets before pushing"
                FAILED=1
                secrets_found=1
                break
            fi
        done
    done
    
    if [ $secrets_found -eq 0 ]; then
        print_message "$GREEN" "✓ No secrets detected in commits"
    fi
    
    # 4. Run tests before push
    print_message "$YELLOW" "→ Running tests..."
    
    # Get the root directory of the git repository
    GIT_ROOT=$(git rev-parse --show-toplevel)
    cd "$GIT_ROOT"
    
    # Check if virtual environment exists and activate it
    if [ -d "venv" ]; then
        source venv/bin/activate
    fi
    
    # Run Python tests if pytest is available
    if command -v pytest &> /dev/null; then
        if [ -d "tests/unit" ]; then
            if ! pytest tests/unit/ -q --tb=short; then
                print_message "$RED" "✗ Unit tests failed"
                print_message "$RED" "  Please fix failing tests before pushing"
                FAILED=1
            else
                print_message "$GREEN" "✓ All unit tests passed"
            fi
        else
            print_message "$YELLOW" "⚠ No unit tests found"
        fi
    else
        print_message "$YELLOW" "⚠ pytest not available, skipping tests"
    fi
    
    # 5. Check commit messages format
    print_message "$YELLOW" "→ Validating commit messages..."
    
    # Get commits being pushed
    commits=$(git rev-list "$remote_sha".."$local_sha" 2>/dev/null || echo "$local_sha")
    invalid_commits=0
    
    for commit in $commits; do
        commit_msg=$(git log -1 --pretty=%B "$commit")
        subject=$(echo "$commit_msg" | head -n1)
        
        # Skip merge commits
        if echo "$subject" | grep -q "^Merge "; then
            continue
        fi
        
        # Check for conventional commit format
        if ! echo "$subject" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert|release|hotfix):"; then
            print_message "$YELLOW" "⚠ Non-conventional commit format: $(echo "$commit" | cut -c1-7)"
            print_message "$YELLOW" "  $subject"
            invalid_commits=$((invalid_commits + 1))
        fi
    done
    
    if [ $invalid_commits -gt 0 ]; then
        print_message "$YELLOW" "⚠ Found $invalid_commits commits with non-conventional format"
        print_message "$YELLOW" "  Consider using conventional commits: https://conventionalcommits.org"
    else
        print_message "$GREEN" "✓ All commit messages follow conventions"
    fi
    
    # 6. Check for WIP commits
    print_message "$YELLOW" "→ Checking for WIP commits..."
    
    wip_found=0
    for commit in $commits; do
        commit_msg=$(git log -1 --pretty=%B "$commit")
        if echo "$commit_msg" | grep -iE "(WIP|work in progress|TODO|FIXME|XXX)" > /dev/null; then
            print_message "$YELLOW" "⚠ WIP/TODO marker found in commit $(echo "$commit" | cut -c1-7)"
            wip_found=1
        fi
    done
    
    if [ $wip_found -eq 0 ]; then
        print_message "$GREEN" "✓ No WIP commits detected"
    fi
    
    # 7. Terraform validation for infrastructure changes
    if git diff --name-only "$remote_sha".."$local_sha" 2>/dev/null | grep -E '\.tf$' > /dev/null; then
        print_message "$YELLOW" "→ Validating Terraform changes..."
        
        if command -v terraform &> /dev/null; then
            tf_dirs=$(git diff --name-only "$remote_sha".."$local_sha" | grep -E '\.tf$' | xargs dirname | sort -u)
            
            for dir in $tf_dirs; do
                if [ -d "$dir" ]; then
                    # Check format
                    if ! terraform fmt -check "$dir" > /dev/null 2>&1; then
                        print_message "$RED" "✗ Terraform formatting issues in $dir"
                        print_message "$YELLOW" "  Run 'terraform fmt' before pushing"
                        FAILED=1
                    fi
                    
                    # Validate if initialized
                    if [ -d "$dir/.terraform" ]; then
                        if ! terraform validate "$dir" > /dev/null 2>&1; then
                            print_message "$RED" "✗ Terraform validation failed in $dir"
                            FAILED=1
                        fi
                    fi
                fi
            done
            
            if [ $FAILED -eq 0 ]; then
                print_message "$GREEN" "✓ Terraform files validated"
            fi
        fi
    fi
    
done

# Final result
print_message "$GREEN" "=================================="

if [ $FAILED -ne 0 ]; then
    print_message "$RED" "Pre-push checks FAILED"
    print_message "$RED" "Please fix the issues above before pushing"
    exit 1
else
    print_message "$GREEN" "All pre-push checks PASSED"
    print_message "$GREEN" "Pushing to $remote..."
fi

exit 0